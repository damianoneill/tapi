// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataTapiTopologyGetTopologyListPostOutput data tapi topology get topology list post output
// swagger:model data_tapi-topology_get-topology-list-post-output
type DataTapiTopologyGetTopologyListPostOutput struct {

	// none (list)
	TapiTopologyTopology []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0 `json:"tapi-topology:topology"`
}

// Validate validates this data tapi topology get topology list post output
func (m *DataTapiTopologyGetTopologyListPostOutput) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTapiTopologyTopology(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutput) validateTapiTopologyTopology(formats strfmt.Registry) error {

	if swag.IsZero(m.TapiTopologyTopology) { // not required
		return nil
	}

	for i := 0; i < len(m.TapiTopologyTopology); i++ {
		if swag.IsZero(m.TapiTopologyTopology[i]) { // not required
			continue
		}

		if m.TapiTopologyTopology[i] != nil {
			if err := m.TapiTopologyTopology[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:topology" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutput) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0 data tapi topology get topology list post output tapi topology topology items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0 struct {

	// none (list)
	BoundaryNodeEdgePoint []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0BoundaryNodeEdgePointItems0 `json:"boundary-node-edge-point"`

	// layer protocol name
	LayerProtocolName []*string `json:"layer-protocol-name"`

	// none (list)
	Link []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0 `json:"link"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NameItems0 `json:"name"`

	// none (list)
	Node []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0 `json:"node"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBoundaryNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayerProtocolName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLink(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0) validateBoundaryNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.BoundaryNodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.BoundaryNodeEdgePoint); i++ {
		if swag.IsZero(m.BoundaryNodeEdgePoint[i]) { // not required
			continue
		}

		if m.BoundaryNodeEdgePoint[i] != nil {
			if err := m.BoundaryNodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("boundary-node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LayerProtocolNameItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODU","ETH","DSR","PHOTONIC_MEDIA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LayerProtocolNameItemsEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LayerProtocolNameItemsEnum, v)
	}
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0) validateLayerProtocolNameItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LayerProtocolNameItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0) validateLayerProtocolName(formats strfmt.Registry) error {

	if swag.IsZero(m.LayerProtocolName) { // not required
		return nil
	}

	for i := 0; i < len(m.LayerProtocolName); i++ {
		if swag.IsZero(m.LayerProtocolName[i]) { // not required
			continue
		}

		// value enum
		if err := m.validateLayerProtocolNameItemsEnum("layer-protocol-name"+"."+strconv.Itoa(i), "body", *m.LayerProtocolName[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0) validateLink(formats strfmt.Registry) error {

	if swag.IsZero(m.Link) { // not required
		return nil
	}

	for i := 0; i < len(m.Link); i++ {
		if swag.IsZero(m.Link[i]) { // not required
			continue
		}

		if m.Link[i] != nil {
			if err := m.Link[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("link" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0) validateNode(formats strfmt.Registry) error {

	if swag.IsZero(m.Node) { // not required
		return nil
	}

	for i := 0; i < len(m.Node); i++ {
		if swag.IsZero(m.Node[i]) { // not required
			continue
		}

		if m.Node[i] != nil {
			if err := m.Node[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0BoundaryNodeEdgePointItems0 data tapi topology get topology list post output tapi topology topology items0 boundary node edge point items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0BoundaryNodeEdgePointItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0BoundaryNodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 boundary node edge point items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0BoundaryNodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0BoundaryNodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0BoundaryNodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0BoundaryNodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0 data tapi topology get topology list post output tapi topology topology items0 link items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0 struct {

	// none (leaf)
	// Enum: [LOCKED UNLOCKED]
	AdministrativeState *string `json:"administrative-state,omitempty"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0CostCharacteristicItems0 `json:"cost-characteristic"`

	// Describes the degree to which packets will be delivered out of sequence.
	// Does not apply to TDM as the TDM protocols maintain strict order. (leaf)
	DeliveryOrderCharacteristic string `json:"delivery-order-characteristic,omitempty"`

	// The directionality of the Link.
	// Is applicable to simple Links where all LinkEnds are BIDIRECTIONAL (the Link will be BIDIRECTIONAL) or UNIDIRECTIONAL (the Link will be UNIDIRECTIONAL).
	// Is not present in more complex cases. (leaf)
	// Enum: [BIDIRECTIONAL UNIDIRECTIONAL UNDEFINED_OR_UNKNOWN]
	Direction *string `json:"direction,omitempty"`

	// Describes the degree to which the signal propagated can be errored.
	// Applies to TDM systems as the errored signal will be propagated and not packet as errored packets will be discarded. (leaf)
	ErrorCharacteristic string `json:"error-characteristic,omitempty"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LatencyCharacteristicItems0 `json:"latency-characteristic"`

	// layer protocol name
	LayerProtocolName []*string `json:"layer-protocol-name"`

	// none (leaf)
	// Enum: [PLANNED POTENTIAL_AVAILABLE POTENTIAL_BUSY INSTALLED PENDING_REMOVAL]
	LifecycleState *string `json:"lifecycle-state,omitempty"`

	// Describes the acceptable characteristic of lost packets where loss may result from discard due to errors or overflow.
	// Applies to packet systems and not TDM (as for TDM errored signals are propagated unless grossly errored and overflow/underflow turns into timing slips). (leaf)
	LossCharacteristic string `json:"loss-characteristic,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NameItems0 `json:"name"`

	// none (list)
	NodeEdgePoint []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NodeEdgePointItems0 `json:"node-edge-point"`

	// none (leaf)
	// Enum: [DISABLED ENABLED]
	OperationalState *string `json:"operational-state,omitempty"`

	// none (leaf)
	// Enum: [NO_PROTECTION ONE_PLUS_ONE_PROTECTION ONE_FOR_ONE_PROTECTION ONE_FOR_N_PROTECTION M_FOR_N_PROTECTION ONE_FOR_ONE_BY_N]
	ProtectionType *string `json:"protection-type,omitempty"`

	// Primarily applies to packet systems where a packet may be delivered more than once (in fault recovery for example).
	// It can also apply to TDM where several frames may be received twice due to switching in a system with a large differential propagation delay. (leaf)
	RepeatDeliveryCharacteristic string `json:"repeat-delivery-characteristic,omitempty"`

	// none (leaf)
	// Enum: [PER_DOMAIN_RESTORATION END_TO_END_RESTORATION NA DYNAMIC_RESTORATION PRE_COMPUTED_RESTORATION]
	RestorationPolicy *string `json:"restoration-policy,omitempty"`

	// A list of risk characteristics for consideration in an analysis of shared risk. Each element of the list represents a specific risk consideration. (list)
	RiskCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RiskCharacteristicItems0 `json:"risk-characteristic"`

	// Describes the effect of any server integrity enhancement process on the characteristics of the TopologicalEntity. (leaf)
	ServerIntegrityProcessCharacteristic string `json:"server-integrity-process-characteristic,omitempty"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// transitioned layer protocol name
	TransitionedLayerProtocolName []string `json:"transitioned-layer-protocol-name"`

	// Describes the duration for which there may be no valid signal propagated. (leaf)
	UnavailableTimeCharacteristic string `json:"unavailable-time-characteristic,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`

	// Provides details of the specific validation mechanism(s) used to confirm the presence of an intended topologicalEntity. (list)
	ValidationMechanism []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ValidationMechanismItems0 `json:"validation-mechanism"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdministrativeState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayerProtocolName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLifecycleState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtectionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestorationPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRiskCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationMechanism(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeAdministrativeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LOCKED","UNLOCKED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeAdministrativeStatePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeAdministrativeStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AdministrativeStateLOCKED captures enum value "LOCKED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AdministrativeStateLOCKED string = "LOCKED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AdministrativeStateUNLOCKED captures enum value "UNLOCKED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AdministrativeStateUNLOCKED string = "UNLOCKED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateAdministrativeStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeAdministrativeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateAdministrativeState(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdministrativeStateEnum("administrative-state", "body", *m.AdministrativeState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BIDIRECTIONAL","UNIDIRECTIONAL","UNDEFINED_OR_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeDirectionPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeDirectionPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0DirectionBIDIRECTIONAL captures enum value "BIDIRECTIONAL"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0DirectionBIDIRECTIONAL string = "BIDIRECTIONAL"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0DirectionUNIDIRECTIONAL captures enum value "UNIDIRECTIONAL"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0DirectionUNIDIRECTIONAL string = "UNIDIRECTIONAL"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0DirectionUNDEFINEDORUNKNOWN captures enum value "UNDEFINED_OR_UNKNOWN"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0DirectionUNDEFINEDORUNKNOWN string = "UNDEFINED_OR_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.Direction) { // not required
		return nil
	}

	// value enum
	if err := m.validateDirectionEnum("direction", "body", *m.Direction); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LayerProtocolNameItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODU","ETH","DSR","PHOTONIC_MEDIA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LayerProtocolNameItemsEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LayerProtocolNameItemsEnum, v)
	}
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateLayerProtocolNameItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LayerProtocolNameItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateLayerProtocolName(formats strfmt.Registry) error {

	if swag.IsZero(m.LayerProtocolName) { // not required
		return nil
	}

	for i := 0; i < len(m.LayerProtocolName); i++ {
		if swag.IsZero(m.LayerProtocolName[i]) { // not required
			continue
		}

		// value enum
		if err := m.validateLayerProtocolNameItemsEnum("layer-protocol-name"+"."+strconv.Itoa(i), "body", *m.LayerProtocolName[i]); err != nil {
			return err
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeLifecycleStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PLANNED","POTENTIAL_AVAILABLE","POTENTIAL_BUSY","INSTALLED","PENDING_REMOVAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeLifecycleStatePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeLifecycleStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LifecycleStatePLANNED captures enum value "PLANNED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LifecycleStatePLANNED string = "PLANNED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LifecycleStatePOTENTIALAVAILABLE captures enum value "POTENTIAL_AVAILABLE"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LifecycleStatePOTENTIALAVAILABLE string = "POTENTIAL_AVAILABLE"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LifecycleStatePOTENTIALBUSY captures enum value "POTENTIAL_BUSY"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LifecycleStatePOTENTIALBUSY string = "POTENTIAL_BUSY"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LifecycleStateINSTALLED captures enum value "INSTALLED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LifecycleStateINSTALLED string = "INSTALLED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LifecycleStatePENDINGREMOVAL captures enum value "PENDING_REMOVAL"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LifecycleStatePENDINGREMOVAL string = "PENDING_REMOVAL"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateLifecycleStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeLifecycleStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateLifecycleState(formats strfmt.Registry) error {

	if swag.IsZero(m.LifecycleState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLifecycleStateEnum("lifecycle-state", "body", *m.LifecycleState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeEdgePoint); i++ {
		if swag.IsZero(m.NodeEdgePoint[i]) { // not required
			continue
		}

		if m.NodeEdgePoint[i] != nil {
			if err := m.NodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeOperationalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DISABLED","ENABLED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeOperationalStatePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeOperationalStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0OperationalStateDISABLED captures enum value "DISABLED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0OperationalStateDISABLED string = "DISABLED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0OperationalStateENABLED captures enum value "ENABLED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0OperationalStateENABLED string = "ENABLED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateOperationalStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeOperationalStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateOperationalState(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationalStateEnum("operational-state", "body", *m.OperationalState); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeProtectionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NO_PROTECTION","ONE_PLUS_ONE_PROTECTION","ONE_FOR_ONE_PROTECTION","ONE_FOR_N_PROTECTION","M_FOR_N_PROTECTION","ONE_FOR_ONE_BY_N"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeProtectionTypePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeProtectionTypePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeNOPROTECTION captures enum value "NO_PROTECTION"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeNOPROTECTION string = "NO_PROTECTION"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeONEPLUSONEPROTECTION captures enum value "ONE_PLUS_ONE_PROTECTION"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeONEPLUSONEPROTECTION string = "ONE_PLUS_ONE_PROTECTION"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeONEFORONEPROTECTION captures enum value "ONE_FOR_ONE_PROTECTION"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeONEFORONEPROTECTION string = "ONE_FOR_ONE_PROTECTION"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeONEFORNPROTECTION captures enum value "ONE_FOR_N_PROTECTION"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeONEFORNPROTECTION string = "ONE_FOR_N_PROTECTION"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeMFORNPROTECTION captures enum value "M_FOR_N_PROTECTION"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeMFORNPROTECTION string = "M_FOR_N_PROTECTION"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeONEFORONEBYN captures enum value "ONE_FOR_ONE_BY_N"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ProtectionTypeONEFORONEBYN string = "ONE_FOR_ONE_BY_N"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateProtectionTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeProtectionTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateProtectionType(formats strfmt.Registry) error {

	if swag.IsZero(m.ProtectionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtectionTypeEnum("protection-type", "body", *m.ProtectionType); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeRestorationPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PER_DOMAIN_RESTORATION","END_TO_END_RESTORATION","NA","DYNAMIC_RESTORATION","PRE_COMPUTED_RESTORATION"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeRestorationPolicyPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeRestorationPolicyPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RestorationPolicyPERDOMAINRESTORATION captures enum value "PER_DOMAIN_RESTORATION"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RestorationPolicyPERDOMAINRESTORATION string = "PER_DOMAIN_RESTORATION"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RestorationPolicyENDTOENDRESTORATION captures enum value "END_TO_END_RESTORATION"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RestorationPolicyENDTOENDRESTORATION string = "END_TO_END_RESTORATION"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RestorationPolicyNA captures enum value "NA"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RestorationPolicyNA string = "NA"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RestorationPolicyDYNAMICRESTORATION captures enum value "DYNAMIC_RESTORATION"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RestorationPolicyDYNAMICRESTORATION string = "DYNAMIC_RESTORATION"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RestorationPolicyPRECOMPUTEDRESTORATION captures enum value "PRE_COMPUTED_RESTORATION"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RestorationPolicyPRECOMPUTEDRESTORATION string = "PRE_COMPUTED_RESTORATION"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateRestorationPolicyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TypeRestorationPolicyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateRestorationPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.RestorationPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateRestorationPolicyEnum("restoration-policy", "body", *m.RestorationPolicy); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateRiskCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.RiskCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.RiskCharacteristic); i++ {
		if swag.IsZero(m.RiskCharacteristic[i]) { // not required
			continue
		}

		if m.RiskCharacteristic[i] != nil {
			if err := m.RiskCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("risk-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) validateValidationMechanism(formats strfmt.Registry) error {

	if swag.IsZero(m.ValidationMechanism) { // not required
		return nil
	}

	for i := 0; i < len(m.ValidationMechanism); i++ {
		if swag.IsZero(m.ValidationMechanism[i]) { // not required
			continue
		}

		if m.ValidationMechanism[i] != nil {
			if err := m.ValidationMechanism[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validation-mechanism" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacity
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0 available capacity
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSize
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0 available capacity total size
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0CostCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 link items0 cost characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0CostCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0CostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0 cost characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0CostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0CostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0CostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0CostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LatencyCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 link items0 latency characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LatencyCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0 latency characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0LatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NameItems0 data tapi topology get topology list post output tapi topology topology items0 link items0 name items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NameItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0 name items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NodeEdgePointItems0 data tapi topology get topology list post output tapi topology topology items0 link items0 node edge point items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NodeEdgePointItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0 node edge point items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0NodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RiskCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 link items0 risk characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RiskCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RiskCharacteristicItems0 struct {

	// The name of the risk characteristic. The characteristic may be related to a specific degree of closeness.
	// For example a particular characteristic may apply to failures that are localized (e.g. to one side of a road) where as another characteristic may relate to failures that have a broader impact (e.g. both sides of a road that crosses a bridge).
	// Depending upon the importance of the traffic being routed different risk characteristics will be evaluated. (leaf)
	RiskCharacteristicName string `json:"risk-characteristic-name,omitempty"`

	// risk identifier list
	RiskIdentifierList []string `json:"risk-identifier-list"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0 risk characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RiskCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RiskCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RiskCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0RiskCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacity
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0 total potential capacity
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0 total potential capacity total size
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ValidationMechanismItems0 data tapi topology get topology list post output tapi topology topology items0 link items0 validation mechanism items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ValidationMechanismItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ValidationMechanismItems0 struct {

	// State of validatiion (leaf)
	LayerProtocolAdjacencyValidated string `json:"layer-protocol-adjacency-validated,omitempty"`

	// Name of mechanism used to validate adjacency (leaf)
	ValidationMechanism string `json:"validation-mechanism,omitempty"`

	// Quality of validation (i.e. how likely is the stated validation to be invalid) (leaf)
	ValidationRobustness string `json:"validation-robustness,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 link items0 validation mechanism items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ValidationMechanismItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ValidationMechanismItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ValidationMechanismItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0LinkItems0ValidationMechanismItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NameItems0 data tapi topology get topology list post output tapi topology topology items0 name items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NameItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 name items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0 data tapi topology get topology list post output tapi topology topology items0 node items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0 struct {

	// none (leaf)
	// Enum: [LOCKED UNLOCKED]
	AdministrativeState *string `json:"administrative-state,omitempty"`

	// none (list)
	AggregatedNodeEdgePoint []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AggregatedNodeEdgePointItems0 `json:"aggregated-node-edge-point"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0CostCharacteristicItems0 `json:"cost-characteristic"`

	// Describes the degree to which packets will be delivered out of sequence.
	// Does not apply to TDM as the TDM protocols maintain strict order. (leaf)
	DeliveryOrderCharacteristic string `json:"delivery-order-characteristic,omitempty"`

	// encap topology
	EncapTopology *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0EncapTopology `json:"encap-topology,omitempty"`

	// Describes the degree to which the signal propagated can be errored.
	// Applies to TDM systems as the errored signal will be propagated and not packet as errored packets will be discarded. (leaf)
	ErrorCharacteristic string `json:"error-characteristic,omitempty"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LatencyCharacteristicItems0 `json:"latency-characteristic"`

	// layer protocol name
	LayerProtocolName []*string `json:"layer-protocol-name"`

	// none (leaf)
	// Enum: [PLANNED POTENTIAL_AVAILABLE POTENTIAL_BUSY INSTALLED PENDING_REMOVAL]
	LifecycleState *string `json:"lifecycle-state,omitempty"`

	// Describes the acceptable characteristic of lost packets where loss may result from discard due to errors or overflow.
	// Applies to packet systems and not TDM (as for TDM errored signals are propagated unless grossly errored and overflow/underflow turns into timing slips). (leaf)
	LossCharacteristic string `json:"loss-characteristic,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NameItems0 `json:"name"`

	// none (list)
	NodeEdgePoint []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0 `json:"node-edge-point"`

	// none (list)
	NodeRuleGroup []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0 `json:"node-rule-group"`

	// none (leaf)
	// Enum: [DISABLED ENABLED]
	OperationalState *string `json:"operational-state,omitempty"`

	// Primarily applies to packet systems where a packet may be delivered more than once (in fault recovery for example).
	// It can also apply to TDM where several frames may be received twice due to switching in a system with a large differential propagation delay. (leaf)
	RepeatDeliveryCharacteristic string `json:"repeat-delivery-characteristic,omitempty"`

	// Describes the effect of any server integrity enhancement process on the characteristics of the TopologicalEntity. (leaf)
	ServerIntegrityProcessCharacteristic string `json:"server-integrity-process-characteristic,omitempty"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// Describes the duration for which there may be no valid signal propagated. (leaf)
	UnavailableTimeCharacteristic string `json:"unavailable-time-characteristic,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdministrativeState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregatedNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncapTopology(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayerProtocolName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLifecycleState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeAdministrativeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LOCKED","UNLOCKED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeAdministrativeStatePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeAdministrativeStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AdministrativeStateLOCKED captures enum value "LOCKED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AdministrativeStateLOCKED string = "LOCKED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AdministrativeStateUNLOCKED captures enum value "UNLOCKED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AdministrativeStateUNLOCKED string = "UNLOCKED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateAdministrativeStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeAdministrativeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateAdministrativeState(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdministrativeStateEnum("administrative-state", "body", *m.AdministrativeState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateAggregatedNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.AggregatedNodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.AggregatedNodeEdgePoint); i++ {
		if swag.IsZero(m.AggregatedNodeEdgePoint[i]) { // not required
			continue
		}

		if m.AggregatedNodeEdgePoint[i] != nil {
			if err := m.AggregatedNodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregated-node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateEncapTopology(formats strfmt.Registry) error {

	if swag.IsZero(m.EncapTopology) { // not required
		return nil
	}

	if m.EncapTopology != nil {
		if err := m.EncapTopology.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encap-topology")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LayerProtocolNameItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODU","ETH","DSR","PHOTONIC_MEDIA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LayerProtocolNameItemsEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LayerProtocolNameItemsEnum, v)
	}
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateLayerProtocolNameItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LayerProtocolNameItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateLayerProtocolName(formats strfmt.Registry) error {

	if swag.IsZero(m.LayerProtocolName) { // not required
		return nil
	}

	for i := 0; i < len(m.LayerProtocolName); i++ {
		if swag.IsZero(m.LayerProtocolName[i]) { // not required
			continue
		}

		// value enum
		if err := m.validateLayerProtocolNameItemsEnum("layer-protocol-name"+"."+strconv.Itoa(i), "body", *m.LayerProtocolName[i]); err != nil {
			return err
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeLifecycleStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PLANNED","POTENTIAL_AVAILABLE","POTENTIAL_BUSY","INSTALLED","PENDING_REMOVAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeLifecycleStatePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeLifecycleStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LifecycleStatePLANNED captures enum value "PLANNED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LifecycleStatePLANNED string = "PLANNED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LifecycleStatePOTENTIALAVAILABLE captures enum value "POTENTIAL_AVAILABLE"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LifecycleStatePOTENTIALAVAILABLE string = "POTENTIAL_AVAILABLE"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LifecycleStatePOTENTIALBUSY captures enum value "POTENTIAL_BUSY"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LifecycleStatePOTENTIALBUSY string = "POTENTIAL_BUSY"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LifecycleStateINSTALLED captures enum value "INSTALLED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LifecycleStateINSTALLED string = "INSTALLED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LifecycleStatePENDINGREMOVAL captures enum value "PENDING_REMOVAL"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LifecycleStatePENDINGREMOVAL string = "PENDING_REMOVAL"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateLifecycleStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeLifecycleStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateLifecycleState(formats strfmt.Registry) error {

	if swag.IsZero(m.LifecycleState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLifecycleStateEnum("lifecycle-state", "body", *m.LifecycleState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeEdgePoint); i++ {
		if swag.IsZero(m.NodeEdgePoint[i]) { // not required
			continue
		}

		if m.NodeEdgePoint[i] != nil {
			if err := m.NodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateNodeRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeRuleGroup); i++ {
		if swag.IsZero(m.NodeRuleGroup[i]) { // not required
			continue
		}

		if m.NodeRuleGroup[i] != nil {
			if err := m.NodeRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeOperationalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DISABLED","ENABLED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeOperationalStatePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeOperationalStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0OperationalStateDISABLED captures enum value "DISABLED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0OperationalStateDISABLED string = "DISABLED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0OperationalStateENABLED captures enum value "ENABLED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0OperationalStateENABLED string = "ENABLED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateOperationalStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TypeOperationalStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateOperationalState(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationalStateEnum("operational-state", "body", *m.OperationalState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AggregatedNodeEdgePointItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 aggregated node edge point items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AggregatedNodeEdgePointItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AggregatedNodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 aggregated node edge point items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AggregatedNodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AggregatedNodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AggregatedNodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AggregatedNodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacity
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 available capacity
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSize
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 available capacity total size
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0CostCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 cost characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0CostCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0CostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 cost characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0CostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0CostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0CostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0CostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0EncapTopology none (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0EncapTopology
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0EncapTopology struct {

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 encap topology
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0EncapTopology) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0EncapTopology) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0EncapTopology) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0EncapTopology
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LatencyCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 latency characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LatencyCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 latency characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0LatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NameItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 name items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NameItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 name items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0 struct {

	// none (leaf)
	// Enum: [LOCKED UNLOCKED]
	AdministrativeState *string `json:"administrative-state,omitempty"`

	// none (list)
	AggregatedNodeEdgePoint []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0 `json:"aggregated-node-edge-point"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// none (list)
	AvailableCepLayerProtocol []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0 `json:"available-cep-layer-protocol"`

	// none (leaf)
	// Enum: [ODU ETH DSR PHOTONIC_MEDIA]
	LayerProtocolName *string `json:"layer-protocol-name,omitempty"`

	// none (leaf)
	// Enum: [PLANNED POTENTIAL_AVAILABLE POTENTIAL_BUSY INSTALLED PENDING_REMOVAL]
	LifecycleState *string `json:"lifecycle-state,omitempty"`

	// The orientation of defined flow at the LinkEnd. (leaf)
	// Enum: [BIDIRECTIONAL INPUT OUTPUT UNIDENTIFIED_OR_UNKNOWN]
	LinkPortDirection *string `json:"link-port-direction,omitempty"`

	// Each LinkEnd of the Link has a role (e.g., symmetric, hub, spoke, leaf, root)  in the context of the Link with respect to the Link function.  (leaf)
	// Enum: [SYMMETRIC ROOT LEAF TRUNK UNKNOWN]
	LinkPortRole *string `json:"link-port-role,omitempty"`

	// NodeEdgePoint mapped to more than ServiceInterfacePoint (slicing/virtualizing) or a ServiceInterfacePoint mapped to more than one NodeEdgePoint (load balancing/Resilience) should be considered experimental (list)
	MappedServiceInterfacePoint []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0 `json:"mapped-service-interface-point"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0NameItems0 `json:"name"`

	// none (leaf)
	// Enum: [DISABLED ENABLED]
	OperationalState *string `json:"operational-state,omitempty"`

	// The overall directionality of the LP.
	// - A BIDIRECTIONAL LP will have some SINK and/or SOURCE flowss.
	// - A SINK LP can only contain elements with SINK flows or CONTRA_DIRECTION_SOURCE flows
	// - A SOURCE LP can only contain SOURCE flows or CONTRA_DIRECTION_SINK flows (leaf)
	// Enum: [BIDIRECTIONAL SINK SOURCE UNDEFINED_OR_UNKNOWN]
	TerminationDirection *string `json:"termination-direction,omitempty"`

	// Indicates whether the layer is terminated and if so how. (leaf)
	// Enum: [LP_CAN_NEVER_TERMINATE LT_NOT_TERMINATED TERMINATED_SERVER_TO_CLIENT_FLOW TERMINATED_CLIENT_TO_SERVER_FLOW TERMINATED_BIDIRECTIONAL LT_PERMENANTLY_TERMINATED TERMINATION_STATE_UNKNOWN]
	TerminationState *string `json:"termination-state,omitempty"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdministrativeState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregatedNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCepLayerProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayerProtocolName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLifecycleState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkPortDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkPortRole(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMappedServiceInterfacePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTerminationDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTerminationState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeAdministrativeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LOCKED","UNLOCKED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeAdministrativeStatePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeAdministrativeStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AdministrativeStateLOCKED captures enum value "LOCKED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AdministrativeStateLOCKED string = "LOCKED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AdministrativeStateUNLOCKED captures enum value "UNLOCKED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AdministrativeStateUNLOCKED string = "UNLOCKED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateAdministrativeStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeAdministrativeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateAdministrativeState(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdministrativeStateEnum("administrative-state", "body", *m.AdministrativeState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateAggregatedNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.AggregatedNodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.AggregatedNodeEdgePoint); i++ {
		if swag.IsZero(m.AggregatedNodeEdgePoint[i]) { // not required
			continue
		}

		if m.AggregatedNodeEdgePoint[i] != nil {
			if err := m.AggregatedNodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregated-node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateAvailableCepLayerProtocol(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCepLayerProtocol) { // not required
		return nil
	}

	for i := 0; i < len(m.AvailableCepLayerProtocol); i++ {
		if swag.IsZero(m.AvailableCepLayerProtocol[i]) { // not required
			continue
		}

		if m.AvailableCepLayerProtocol[i] != nil {
			if err := m.AvailableCepLayerProtocol[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("available-cep-layer-protocol" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLayerProtocolNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODU","ETH","DSR","PHOTONIC_MEDIA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLayerProtocolNamePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLayerProtocolNamePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LayerProtocolNameODU captures enum value "ODU"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LayerProtocolNameODU string = "ODU"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LayerProtocolNameETH captures enum value "ETH"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LayerProtocolNameETH string = "ETH"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LayerProtocolNameDSR captures enum value "DSR"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LayerProtocolNameDSR string = "DSR"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LayerProtocolNamePHOTONICMEDIA captures enum value "PHOTONIC_MEDIA"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LayerProtocolNamePHOTONICMEDIA string = "PHOTONIC_MEDIA"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateLayerProtocolNameEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLayerProtocolNamePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateLayerProtocolName(formats strfmt.Registry) error {

	if swag.IsZero(m.LayerProtocolName) { // not required
		return nil
	}

	// value enum
	if err := m.validateLayerProtocolNameEnum("layer-protocol-name", "body", *m.LayerProtocolName); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLifecycleStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PLANNED","POTENTIAL_AVAILABLE","POTENTIAL_BUSY","INSTALLED","PENDING_REMOVAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLifecycleStatePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLifecycleStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LifecycleStatePLANNED captures enum value "PLANNED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LifecycleStatePLANNED string = "PLANNED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LifecycleStatePOTENTIALAVAILABLE captures enum value "POTENTIAL_AVAILABLE"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LifecycleStatePOTENTIALAVAILABLE string = "POTENTIAL_AVAILABLE"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LifecycleStatePOTENTIALBUSY captures enum value "POTENTIAL_BUSY"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LifecycleStatePOTENTIALBUSY string = "POTENTIAL_BUSY"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LifecycleStateINSTALLED captures enum value "INSTALLED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LifecycleStateINSTALLED string = "INSTALLED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LifecycleStatePENDINGREMOVAL captures enum value "PENDING_REMOVAL"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LifecycleStatePENDINGREMOVAL string = "PENDING_REMOVAL"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateLifecycleStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLifecycleStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateLifecycleState(formats strfmt.Registry) error {

	if swag.IsZero(m.LifecycleState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLifecycleStateEnum("lifecycle-state", "body", *m.LifecycleState); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLinkPortDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BIDIRECTIONAL","INPUT","OUTPUT","UNIDENTIFIED_OR_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLinkPortDirectionPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLinkPortDirectionPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortDirectionBIDIRECTIONAL captures enum value "BIDIRECTIONAL"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortDirectionBIDIRECTIONAL string = "BIDIRECTIONAL"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortDirectionINPUT captures enum value "INPUT"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortDirectionINPUT string = "INPUT"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortDirectionOUTPUT captures enum value "OUTPUT"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortDirectionOUTPUT string = "OUTPUT"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortDirectionUNIDENTIFIEDORUNKNOWN captures enum value "UNIDENTIFIED_OR_UNKNOWN"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortDirectionUNIDENTIFIEDORUNKNOWN string = "UNIDENTIFIED_OR_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateLinkPortDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLinkPortDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateLinkPortDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.LinkPortDirection) { // not required
		return nil
	}

	// value enum
	if err := m.validateLinkPortDirectionEnum("link-port-direction", "body", *m.LinkPortDirection); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLinkPortRolePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SYMMETRIC","ROOT","LEAF","TRUNK","UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLinkPortRolePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLinkPortRolePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortRoleSYMMETRIC captures enum value "SYMMETRIC"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortRoleSYMMETRIC string = "SYMMETRIC"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortRoleROOT captures enum value "ROOT"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortRoleROOT string = "ROOT"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortRoleLEAF captures enum value "LEAF"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortRoleLEAF string = "LEAF"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortRoleTRUNK captures enum value "TRUNK"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortRoleTRUNK string = "TRUNK"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortRoleUNKNOWN captures enum value "UNKNOWN"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0LinkPortRoleUNKNOWN string = "UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateLinkPortRoleEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeLinkPortRolePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateLinkPortRole(formats strfmt.Registry) error {

	if swag.IsZero(m.LinkPortRole) { // not required
		return nil
	}

	// value enum
	if err := m.validateLinkPortRoleEnum("link-port-role", "body", *m.LinkPortRole); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateMappedServiceInterfacePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.MappedServiceInterfacePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.MappedServiceInterfacePoint); i++ {
		if swag.IsZero(m.MappedServiceInterfacePoint[i]) { // not required
			continue
		}

		if m.MappedServiceInterfacePoint[i] != nil {
			if err := m.MappedServiceInterfacePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mapped-service-interface-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeOperationalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DISABLED","ENABLED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeOperationalStatePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeOperationalStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0OperationalStateDISABLED captures enum value "DISABLED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0OperationalStateDISABLED string = "DISABLED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0OperationalStateENABLED captures enum value "ENABLED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0OperationalStateENABLED string = "ENABLED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateOperationalStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeOperationalStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateOperationalState(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationalStateEnum("operational-state", "body", *m.OperationalState); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeTerminationDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BIDIRECTIONAL","SINK","SOURCE","UNDEFINED_OR_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeTerminationDirectionPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeTerminationDirectionPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationDirectionBIDIRECTIONAL captures enum value "BIDIRECTIONAL"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationDirectionBIDIRECTIONAL string = "BIDIRECTIONAL"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationDirectionSINK captures enum value "SINK"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationDirectionSINK string = "SINK"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationDirectionSOURCE captures enum value "SOURCE"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationDirectionSOURCE string = "SOURCE"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationDirectionUNDEFINEDORUNKNOWN captures enum value "UNDEFINED_OR_UNKNOWN"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationDirectionUNDEFINEDORUNKNOWN string = "UNDEFINED_OR_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateTerminationDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeTerminationDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateTerminationDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.TerminationDirection) { // not required
		return nil
	}

	// value enum
	if err := m.validateTerminationDirectionEnum("termination-direction", "body", *m.TerminationDirection); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeTerminationStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LP_CAN_NEVER_TERMINATE","LT_NOT_TERMINATED","TERMINATED_SERVER_TO_CLIENT_FLOW","TERMINATED_CLIENT_TO_SERVER_FLOW","TERMINATED_BIDIRECTIONAL","LT_PERMENANTLY_TERMINATED","TERMINATION_STATE_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeTerminationStatePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeTerminationStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateLPCANNEVERTERMINATE captures enum value "LP_CAN_NEVER_TERMINATE"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateLPCANNEVERTERMINATE string = "LP_CAN_NEVER_TERMINATE"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateLTNOTTERMINATED captures enum value "LT_NOT_TERMINATED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateLTNOTTERMINATED string = "LT_NOT_TERMINATED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateTERMINATEDSERVERTOCLIENTFLOW captures enum value "TERMINATED_SERVER_TO_CLIENT_FLOW"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateTERMINATEDSERVERTOCLIENTFLOW string = "TERMINATED_SERVER_TO_CLIENT_FLOW"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateTERMINATEDCLIENTTOSERVERFLOW captures enum value "TERMINATED_CLIENT_TO_SERVER_FLOW"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateTERMINATEDCLIENTTOSERVERFLOW string = "TERMINATED_CLIENT_TO_SERVER_FLOW"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateTERMINATEDBIDIRECTIONAL captures enum value "TERMINATED_BIDIRECTIONAL"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateTERMINATEDBIDIRECTIONAL string = "TERMINATED_BIDIRECTIONAL"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateLTPERMENANTLYTERMINATED captures enum value "LT_PERMENANTLY_TERMINATED"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateLTPERMENANTLYTERMINATED string = "LT_PERMENANTLY_TERMINATED"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateTERMINATIONSTATEUNKNOWN captures enum value "TERMINATION_STATE_UNKNOWN"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TerminationStateTERMINATIONSTATEUNKNOWN string = "TERMINATION_STATE_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateTerminationStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TypeTerminationStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateTerminationState(formats strfmt.Registry) error {

	if swag.IsZero(m.TerminationState) { // not required
		return nil
	}

	// value enum
	if err := m.validateTerminationStateEnum("termination-state", "body", *m.TerminationState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 aggregated node edge point items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 aggregated node edge point items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacity
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 available capacity
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSize
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 available capacity total size
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 available cep layer protocol items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0 struct {

	// none (leaf)
	LayerProtocolQualifier string `json:"layer-protocol-qualifier,omitempty"`

	// none (leaf)
	NumberOfCepInstances uint64 `json:"number-of-cep-instances,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 available cep layer protocol items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 mapped service interface point items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0 struct {

	// none (leaf)
	ServiceInterfacePointUUID string `json:"service-interface-point-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 mapped service interface point items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0NameItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 name items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0NameItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 name items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacity
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 total potential capacity
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node edge point items0 total potential capacity total size
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0 struct {

	// available capacity
	AvailableCapacity *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// none (list)
	ComposedRuleGroup []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0 `json:"composed-rule-group"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0CostCharacteristicItems0 `json:"cost-characteristic"`

	// none (list)
	InterRuleGroup []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0 `json:"inter-rule-group"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0 `json:"latency-characteristic"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NameItems0 `json:"name"`

	// none (list)
	NodeEdgePoint []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NodeEdgePointItems0 `json:"node-edge-point"`

	// A list of risk characteristics for consideration in an analysis of shared risk. Each element of the list represents a specific risk consideration. (list)
	RiskCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RiskCharacteristicItems0 `json:"risk-characteristic"`

	// none (list)
	Rule []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0 `json:"rule"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComposedRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRiskCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) validateComposedRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.ComposedRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.ComposedRuleGroup); i++ {
		if swag.IsZero(m.ComposedRuleGroup[i]) { // not required
			continue
		}

		if m.ComposedRuleGroup[i] != nil {
			if err := m.ComposedRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("composed-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) validateInterRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.InterRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.InterRuleGroup); i++ {
		if swag.IsZero(m.InterRuleGroup[i]) { // not required
			continue
		}

		if m.InterRuleGroup[i] != nil {
			if err := m.InterRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inter-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) validateNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeEdgePoint); i++ {
		if swag.IsZero(m.NodeEdgePoint[i]) { // not required
			continue
		}

		if m.NodeEdgePoint[i] != nil {
			if err := m.NodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) validateRiskCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.RiskCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.RiskCharacteristic); i++ {
		if swag.IsZero(m.RiskCharacteristic[i]) { // not required
			continue
		}

		if m.RiskCharacteristic[i] != nil {
			if err := m.RiskCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("risk-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) validateRule(formats strfmt.Registry) error {

	if swag.IsZero(m.Rule) { // not required
		return nil
	}

	for i := 0; i < len(m.Rule); i++ {
		if swag.IsZero(m.Rule[i]) { // not required
			continue
		}

		if m.Rule[i] != nil {
			if err := m.Rule[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rule" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacity
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 available capacity
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 available capacity total size
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 composed rule group items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0 struct {

	// none (leaf)
	NodeRuleGroupUUID string `json:"node-rule-group-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 composed rule group items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0CostCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 cost characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0CostCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0CostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 cost characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0CostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0CostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0CostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0CostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0 struct {

	// none (list)
	AssociatedNodeRuleGroup []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0 `json:"associated-node-rule-group"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0 `json:"cost-characteristic"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0 `json:"latency-characteristic"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0 `json:"name"`

	// A list of risk characteristics for consideration in an analysis of shared risk. Each element of the list represents a specific risk consideration. (list)
	RiskCharacteristic []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0 `json:"risk-characteristic"`

	// none (list)
	Rule []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0 `json:"rule"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssociatedNodeRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRiskCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateAssociatedNodeRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.AssociatedNodeRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.AssociatedNodeRuleGroup); i++ {
		if swag.IsZero(m.AssociatedNodeRuleGroup[i]) { // not required
			continue
		}

		if m.AssociatedNodeRuleGroup[i] != nil {
			if err := m.AssociatedNodeRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("associated-node-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateRiskCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.RiskCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.RiskCharacteristic); i++ {
		if swag.IsZero(m.RiskCharacteristic[i]) { // not required
			continue
		}

		if m.RiskCharacteristic[i] != nil {
			if err := m.RiskCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("risk-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateRule(formats strfmt.Registry) error {

	if swag.IsZero(m.Rule) { // not required
		return nil
	}

	for i := 0; i < len(m.Rule); i++ {
		if swag.IsZero(m.Rule[i]) { // not required
			continue
		}

		if m.Rule[i] != nil {
			if err := m.Rule[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rule" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 associated node rule group items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0 struct {

	// none (leaf)
	NodeRuleGroupUUID string `json:"node-rule-group-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 associated node rule group items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 available capacity
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 available capacity total size
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 cost characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 cost characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 latency characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 latency characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 name items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 name items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 risk characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0 struct {

	// The name of the risk characteristic. The characteristic may be related to a specific degree of closeness.
	// For example a particular characteristic may apply to failures that are localized (e.g. to one side of a road) where as another characteristic may relate to failures that have a broader impact (e.g. both sides of a road that crosses a bridge).
	// Depending upon the importance of the traffic being routed different risk characteristics will be evaluated. (leaf)
	RiskCharacteristicName string `json:"risk-characteristic-name,omitempty"`

	// risk identifier list
	RiskIdentifierList []string `json:"risk-identifier-list"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 risk characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 rule items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0 struct {

	// none (leaf)
	// Enum: [MAY_FORWARD_ACROSS_GROUP MUST_FORWARD_ACROSS_GROUP CANNOT_FORWARD_ACROSS_GROUP NO_STATEMENT_ON_FORWARDING]
	ForwardingRule *string `json:"forwarding-rule,omitempty"`

	// none (leaf)
	LocalID string `json:"local-id,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0 `json:"name"`

	// none (leaf)
	OverridePriority uint64 `json:"override-priority,omitempty"`

	// none (leaf)
	// Enum: [FORWARDING CAPACITY COST TIMING RISK GROUPING]
	RuleType *string `json:"rule-type,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 rule items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateForwardingRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRuleType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MAY_FORWARD_ACROSS_GROUP","MUST_FORWARD_ACROSS_GROUP","CANNOT_FORWARD_ACROSS_GROUP","NO_STATEMENT_ON_FORWARDING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP captures enum value "MAY_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP string = "MAY_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP captures enum value "MUST_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP string = "MUST_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP captures enum value "CANNOT_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP string = "CANNOT_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING captures enum value "NO_STATEMENT_ON_FORWARDING"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING string = "NO_STATEMENT_ON_FORWARDING"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateForwardingRuleEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateForwardingRule(formats strfmt.Registry) error {

	if swag.IsZero(m.ForwardingRule) { // not required
		return nil
	}

	// value enum
	if err := m.validateForwardingRuleEnum("forwarding-rule", "body", *m.ForwardingRule); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FORWARDING","CAPACITY","COST","TIMING","RISK","GROUPING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeFORWARDING captures enum value "FORWARDING"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeFORWARDING string = "FORWARDING"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCAPACITY captures enum value "CAPACITY"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCAPACITY string = "CAPACITY"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCOST captures enum value "COST"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCOST string = "COST"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeTIMING captures enum value "TIMING"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeTIMING string = "TIMING"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeRISK captures enum value "RISK"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeRISK string = "RISK"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeGROUPING captures enum value "GROUPING"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeGROUPING string = "GROUPING"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateRuleTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateRuleType(formats strfmt.Registry) error {

	if swag.IsZero(m.RuleType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRuleTypeEnum("rule-type", "body", *m.RuleType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 rule items0 name items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 rule items0 name items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 total potential capacity
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 inter rule group items0 total potential capacity total size
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 latency characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 latency characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NameItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 name items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NameItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 name items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NodeEdgePointItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 node edge point items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NodeEdgePointItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 node edge point items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0NodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RiskCharacteristicItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 risk characteristic items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RiskCharacteristicItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RiskCharacteristicItems0 struct {

	// The name of the risk characteristic. The characteristic may be related to a specific degree of closeness.
	// For example a particular characteristic may apply to failures that are localized (e.g. to one side of a road) where as another characteristic may relate to failures that have a broader impact (e.g. both sides of a road that crosses a bridge).
	// Depending upon the importance of the traffic being routed different risk characteristics will be evaluated. (leaf)
	RiskCharacteristicName string `json:"risk-characteristic-name,omitempty"`

	// risk identifier list
	RiskIdentifierList []string `json:"risk-identifier-list"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 risk characteristic items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RiskCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RiskCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RiskCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RiskCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 rule items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0 struct {

	// none (leaf)
	// Enum: [MAY_FORWARD_ACROSS_GROUP MUST_FORWARD_ACROSS_GROUP CANNOT_FORWARD_ACROSS_GROUP NO_STATEMENT_ON_FORWARDING]
	ForwardingRule *string `json:"forwarding-rule,omitempty"`

	// none (leaf)
	LocalID string `json:"local-id,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0NameItems0 `json:"name"`

	// none (leaf)
	OverridePriority uint64 `json:"override-priority,omitempty"`

	// none (leaf)
	// Enum: [FORWARDING CAPACITY COST TIMING RISK GROUPING]
	RuleType *string `json:"rule-type,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 rule items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateForwardingRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRuleType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MAY_FORWARD_ACROSS_GROUP","MUST_FORWARD_ACROSS_GROUP","CANNOT_FORWARD_ACROSS_GROUP","NO_STATEMENT_ON_FORWARDING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP captures enum value "MAY_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP string = "MAY_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP captures enum value "MUST_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP string = "MUST_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP captures enum value "CANNOT_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP string = "CANNOT_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING captures enum value "NO_STATEMENT_ON_FORWARDING"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING string = "NO_STATEMENT_ON_FORWARDING"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0) validateForwardingRuleEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0) validateForwardingRule(formats strfmt.Registry) error {

	if swag.IsZero(m.ForwardingRule) { // not required
		return nil
	}

	// value enum
	if err := m.validateForwardingRuleEnum("forwarding-rule", "body", *m.ForwardingRule); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FORWARDING","CAPACITY","COST","TIMING","RISK","GROUPING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeFORWARDING captures enum value "FORWARDING"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeFORWARDING string = "FORWARDING"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeCAPACITY captures enum value "CAPACITY"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeCAPACITY string = "CAPACITY"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeCOST captures enum value "COST"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeCOST string = "COST"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeTIMING captures enum value "TIMING"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeTIMING string = "TIMING"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeRISK captures enum value "RISK"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeRISK string = "RISK"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeGROUPING captures enum value "GROUPING"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0RuleTypeGROUPING string = "GROUPING"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0) validateRuleTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0) validateRuleType(formats strfmt.Registry) error {

	if swag.IsZero(m.RuleType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRuleTypeEnum("rule-type", "body", *m.RuleType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0NameItems0 data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 rule items0 name items0
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0NameItems0
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 rule items0 name items0
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0RuleItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacity
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 total potential capacity
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 node rule group items0 total potential capacity total size
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacity
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 total potential capacity
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology list post output tapi topology topology items0 node items0 total potential capacity total size
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyListPostOutputTapiTopologyTopologyItems0NodeItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
