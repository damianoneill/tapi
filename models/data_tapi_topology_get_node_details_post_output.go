// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataTapiTopologyGetNodeDetailsPostOutput data tapi topology get node details post output
// swagger:model data_tapi-topology_get-node-details-post-output
type DataTapiTopologyGetNodeDetailsPostOutput struct {

	// tapi topology node
	TapiTopologyNode *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode `json:"tapi-topology:node,omitempty"`
}

// Validate validates this data tapi topology get node details post output
func (m *DataTapiTopologyGetNodeDetailsPostOutput) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTapiTopologyNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutput) validateTapiTopologyNode(formats strfmt.Registry) error {

	if swag.IsZero(m.TapiTopologyNode) { // not required
		return nil
	}

	if m.TapiTopologyNode != nil {
		if err := m.TapiTopologyNode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tapi-topology:node")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutput) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode none (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode struct {

	// none (leaf)
	// Enum: [LOCKED UNLOCKED]
	AdministrativeState *string `json:"administrative-state,omitempty"`

	// none (list)
	AggregatedNodeEdgePoint []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAggregatedNodeEdgePointItems0 `json:"aggregated-node-edge-point"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacity `json:"available-capacity,omitempty"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeCostCharacteristicItems0 `json:"cost-characteristic"`

	// Describes the degree to which packets will be delivered out of sequence.
	// Does not apply to TDM as the TDM protocols maintain strict order. (leaf)
	DeliveryOrderCharacteristic string `json:"delivery-order-characteristic,omitempty"`

	// encap topology
	EncapTopology *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeEncapTopology `json:"encap-topology,omitempty"`

	// Describes the degree to which the signal propagated can be errored.
	// Applies to TDM systems as the errored signal will be propagated and not packet as errored packets will be discarded. (leaf)
	ErrorCharacteristic string `json:"error-characteristic,omitempty"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLatencyCharacteristicItems0 `json:"latency-characteristic"`

	// layer protocol name
	LayerProtocolName []*string `json:"layer-protocol-name"`

	// none (leaf)
	// Enum: [PLANNED POTENTIAL_AVAILABLE POTENTIAL_BUSY INSTALLED PENDING_REMOVAL]
	LifecycleState *string `json:"lifecycle-state,omitempty"`

	// Describes the acceptable characteristic of lost packets where loss may result from discard due to errors or overflow.
	// Applies to packet systems and not TDM (as for TDM errored signals are propagated unless grossly errored and overflow/underflow turns into timing slips). (leaf)
	LossCharacteristic string `json:"loss-characteristic,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNameItems0 `json:"name"`

	// none (list)
	NodeEdgePoint []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0 `json:"node-edge-point"`

	// none (list)
	NodeRuleGroup []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0 `json:"node-rule-group"`

	// none (leaf)
	// Enum: [DISABLED ENABLED]
	OperationalState *string `json:"operational-state,omitempty"`

	// Primarily applies to packet systems where a packet may be delivered more than once (in fault recovery for example).
	// It can also apply to TDM where several frames may be received twice due to switching in a system with a large differential propagation delay. (leaf)
	RepeatDeliveryCharacteristic string `json:"repeat-delivery-characteristic,omitempty"`

	// Describes the effect of any server integrity enhancement process on the characteristics of the TopologicalEntity. (leaf)
	ServerIntegrityProcessCharacteristic string `json:"server-integrity-process-characteristic,omitempty"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// Describes the duration for which there may be no valid signal propagated. (leaf)
	UnavailableTimeCharacteristic string `json:"unavailable-time-characteristic,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdministrativeState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregatedNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncapTopology(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayerProtocolName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLifecycleState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeAdministrativeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LOCKED","UNLOCKED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeAdministrativeStatePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeAdministrativeStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAdministrativeStateLOCKED captures enum value "LOCKED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAdministrativeStateLOCKED string = "LOCKED"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAdministrativeStateUNLOCKED captures enum value "UNLOCKED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAdministrativeStateUNLOCKED string = "UNLOCKED"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateAdministrativeStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeAdministrativeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateAdministrativeState(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdministrativeStateEnum("tapi-topology:node"+"."+"administrative-state", "body", *m.AdministrativeState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateAggregatedNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.AggregatedNodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.AggregatedNodeEdgePoint); i++ {
		if swag.IsZero(m.AggregatedNodeEdgePoint[i]) { // not required
			continue
		}

		if m.AggregatedNodeEdgePoint[i] != nil {
			if err := m.AggregatedNodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:node" + "." + "aggregated-node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tapi-topology:node" + "." + "available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:node" + "." + "cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateEncapTopology(formats strfmt.Registry) error {

	if swag.IsZero(m.EncapTopology) { // not required
		return nil
	}

	if m.EncapTopology != nil {
		if err := m.EncapTopology.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tapi-topology:node" + "." + "encap-topology")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:node" + "." + "latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLayerProtocolNameItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODU","ETH","DSR","PHOTONIC_MEDIA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLayerProtocolNameItemsEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLayerProtocolNameItemsEnum, v)
	}
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateLayerProtocolNameItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLayerProtocolNameItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateLayerProtocolName(formats strfmt.Registry) error {

	if swag.IsZero(m.LayerProtocolName) { // not required
		return nil
	}

	for i := 0; i < len(m.LayerProtocolName); i++ {
		if swag.IsZero(m.LayerProtocolName[i]) { // not required
			continue
		}

		// value enum
		if err := m.validateLayerProtocolNameItemsEnum("tapi-topology:node"+"."+"layer-protocol-name"+"."+strconv.Itoa(i), "body", *m.LayerProtocolName[i]); err != nil {
			return err
		}

	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeLifecycleStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PLANNED","POTENTIAL_AVAILABLE","POTENTIAL_BUSY","INSTALLED","PENDING_REMOVAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeLifecycleStatePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeLifecycleStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLifecycleStatePLANNED captures enum value "PLANNED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLifecycleStatePLANNED string = "PLANNED"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLifecycleStatePOTENTIALAVAILABLE captures enum value "POTENTIAL_AVAILABLE"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLifecycleStatePOTENTIALAVAILABLE string = "POTENTIAL_AVAILABLE"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLifecycleStatePOTENTIALBUSY captures enum value "POTENTIAL_BUSY"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLifecycleStatePOTENTIALBUSY string = "POTENTIAL_BUSY"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLifecycleStateINSTALLED captures enum value "INSTALLED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLifecycleStateINSTALLED string = "INSTALLED"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLifecycleStatePENDINGREMOVAL captures enum value "PENDING_REMOVAL"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLifecycleStatePENDINGREMOVAL string = "PENDING_REMOVAL"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateLifecycleStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeLifecycleStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateLifecycleState(formats strfmt.Registry) error {

	if swag.IsZero(m.LifecycleState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLifecycleStateEnum("tapi-topology:node"+"."+"lifecycle-state", "body", *m.LifecycleState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:node" + "." + "name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeEdgePoint); i++ {
		if swag.IsZero(m.NodeEdgePoint[i]) { // not required
			continue
		}

		if m.NodeEdgePoint[i] != nil {
			if err := m.NodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:node" + "." + "node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateNodeRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeRuleGroup); i++ {
		if swag.IsZero(m.NodeRuleGroup[i]) { // not required
			continue
		}

		if m.NodeRuleGroup[i] != nil {
			if err := m.NodeRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:node" + "." + "node-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeOperationalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DISABLED","ENABLED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeOperationalStatePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeOperationalStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeOperationalStateDISABLED captures enum value "DISABLED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeOperationalStateDISABLED string = "DISABLED"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeOperationalStateENABLED captures enum value "ENABLED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeOperationalStateENABLED string = "ENABLED"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateOperationalStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTypeOperationalStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateOperationalState(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationalStateEnum("tapi-topology:node"+"."+"operational-state", "body", *m.OperationalState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tapi-topology:node" + "." + "total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNode
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAggregatedNodeEdgePointItems0 data tapi topology get node details post output tapi topology node aggregated node edge point items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAggregatedNodeEdgePointItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAggregatedNodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node aggregated node edge point items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAggregatedNodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAggregatedNodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAggregatedNodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAggregatedNodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacity
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node available capacity
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tapi-topology:node" + "." + "available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSize
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node available capacity total size
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("tapi-topology:node"+"."+"available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeAvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeCostCharacteristicItems0 data tapi topology get node details post output tapi topology node cost characteristic items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeCostCharacteristicItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeCostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node cost characteristic items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeCostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeCostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeCostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeCostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeEncapTopology none (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeEncapTopology
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeEncapTopology struct {

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node encap topology
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeEncapTopology) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeEncapTopology) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeEncapTopology) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeEncapTopology
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLatencyCharacteristicItems0 data tapi topology get node details post output tapi topology node latency characteristic items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLatencyCharacteristicItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node latency characteristic items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeLatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNameItems0 data tapi topology get node details post output tapi topology node name items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNameItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node name items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0 data tapi topology get node details post output tapi topology node node edge point items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0 struct {

	// none (leaf)
	// Enum: [LOCKED UNLOCKED]
	AdministrativeState *string `json:"administrative-state,omitempty"`

	// none (list)
	AggregatedNodeEdgePoint []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AggregatedNodeEdgePointItems0 `json:"aggregated-node-edge-point"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// none (list)
	AvailableCepLayerProtocol []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCepLayerProtocolItems0 `json:"available-cep-layer-protocol"`

	// none (leaf)
	// Enum: [ODU ETH DSR PHOTONIC_MEDIA]
	LayerProtocolName *string `json:"layer-protocol-name,omitempty"`

	// none (leaf)
	// Enum: [PLANNED POTENTIAL_AVAILABLE POTENTIAL_BUSY INSTALLED PENDING_REMOVAL]
	LifecycleState *string `json:"lifecycle-state,omitempty"`

	// The orientation of defined flow at the LinkEnd. (leaf)
	// Enum: [BIDIRECTIONAL INPUT OUTPUT UNIDENTIFIED_OR_UNKNOWN]
	LinkPortDirection *string `json:"link-port-direction,omitempty"`

	// Each LinkEnd of the Link has a role (e.g., symmetric, hub, spoke, leaf, root)  in the context of the Link with respect to the Link function.  (leaf)
	// Enum: [SYMMETRIC ROOT LEAF TRUNK UNKNOWN]
	LinkPortRole *string `json:"link-port-role,omitempty"`

	// NodeEdgePoint mapped to more than ServiceInterfacePoint (slicing/virtualizing) or a ServiceInterfacePoint mapped to more than one NodeEdgePoint (load balancing/Resilience) should be considered experimental (list)
	MappedServiceInterfacePoint []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0MappedServiceInterfacePointItems0 `json:"mapped-service-interface-point"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0NameItems0 `json:"name"`

	// none (leaf)
	// Enum: [DISABLED ENABLED]
	OperationalState *string `json:"operational-state,omitempty"`

	// The overall directionality of the LP.
	// - A BIDIRECTIONAL LP will have some SINK and/or SOURCE flowss.
	// - A SINK LP can only contain elements with SINK flows or CONTRA_DIRECTION_SOURCE flows
	// - A SOURCE LP can only contain SOURCE flows or CONTRA_DIRECTION_SINK flows (leaf)
	// Enum: [BIDIRECTIONAL SINK SOURCE UNDEFINED_OR_UNKNOWN]
	TerminationDirection *string `json:"termination-direction,omitempty"`

	// Indicates whether the layer is terminated and if so how. (leaf)
	// Enum: [LP_CAN_NEVER_TERMINATE LT_NOT_TERMINATED TERMINATED_SERVER_TO_CLIENT_FLOW TERMINATED_CLIENT_TO_SERVER_FLOW TERMINATED_BIDIRECTIONAL LT_PERMENANTLY_TERMINATED TERMINATION_STATE_UNKNOWN]
	TerminationState *string `json:"termination-state,omitempty"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node edge point items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdministrativeState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregatedNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCepLayerProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayerProtocolName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLifecycleState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkPortDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkPortRole(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMappedServiceInterfacePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTerminationDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTerminationState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeAdministrativeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LOCKED","UNLOCKED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeAdministrativeStatePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeAdministrativeStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AdministrativeStateLOCKED captures enum value "LOCKED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AdministrativeStateLOCKED string = "LOCKED"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AdministrativeStateUNLOCKED captures enum value "UNLOCKED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AdministrativeStateUNLOCKED string = "UNLOCKED"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateAdministrativeStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeAdministrativeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateAdministrativeState(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdministrativeStateEnum("administrative-state", "body", *m.AdministrativeState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateAggregatedNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.AggregatedNodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.AggregatedNodeEdgePoint); i++ {
		if swag.IsZero(m.AggregatedNodeEdgePoint[i]) { // not required
			continue
		}

		if m.AggregatedNodeEdgePoint[i] != nil {
			if err := m.AggregatedNodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregated-node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateAvailableCepLayerProtocol(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCepLayerProtocol) { // not required
		return nil
	}

	for i := 0; i < len(m.AvailableCepLayerProtocol); i++ {
		if swag.IsZero(m.AvailableCepLayerProtocol[i]) { // not required
			continue
		}

		if m.AvailableCepLayerProtocol[i] != nil {
			if err := m.AvailableCepLayerProtocol[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("available-cep-layer-protocol" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLayerProtocolNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODU","ETH","DSR","PHOTONIC_MEDIA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLayerProtocolNamePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLayerProtocolNamePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LayerProtocolNameODU captures enum value "ODU"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LayerProtocolNameODU string = "ODU"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LayerProtocolNameETH captures enum value "ETH"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LayerProtocolNameETH string = "ETH"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LayerProtocolNameDSR captures enum value "DSR"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LayerProtocolNameDSR string = "DSR"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LayerProtocolNamePHOTONICMEDIA captures enum value "PHOTONIC_MEDIA"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LayerProtocolNamePHOTONICMEDIA string = "PHOTONIC_MEDIA"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateLayerProtocolNameEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLayerProtocolNamePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateLayerProtocolName(formats strfmt.Registry) error {

	if swag.IsZero(m.LayerProtocolName) { // not required
		return nil
	}

	// value enum
	if err := m.validateLayerProtocolNameEnum("layer-protocol-name", "body", *m.LayerProtocolName); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLifecycleStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PLANNED","POTENTIAL_AVAILABLE","POTENTIAL_BUSY","INSTALLED","PENDING_REMOVAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLifecycleStatePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLifecycleStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LifecycleStatePLANNED captures enum value "PLANNED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LifecycleStatePLANNED string = "PLANNED"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LifecycleStatePOTENTIALAVAILABLE captures enum value "POTENTIAL_AVAILABLE"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LifecycleStatePOTENTIALAVAILABLE string = "POTENTIAL_AVAILABLE"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LifecycleStatePOTENTIALBUSY captures enum value "POTENTIAL_BUSY"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LifecycleStatePOTENTIALBUSY string = "POTENTIAL_BUSY"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LifecycleStateINSTALLED captures enum value "INSTALLED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LifecycleStateINSTALLED string = "INSTALLED"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LifecycleStatePENDINGREMOVAL captures enum value "PENDING_REMOVAL"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LifecycleStatePENDINGREMOVAL string = "PENDING_REMOVAL"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateLifecycleStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLifecycleStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateLifecycleState(formats strfmt.Registry) error {

	if swag.IsZero(m.LifecycleState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLifecycleStateEnum("lifecycle-state", "body", *m.LifecycleState); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLinkPortDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BIDIRECTIONAL","INPUT","OUTPUT","UNIDENTIFIED_OR_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLinkPortDirectionPropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLinkPortDirectionPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortDirectionBIDIRECTIONAL captures enum value "BIDIRECTIONAL"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortDirectionBIDIRECTIONAL string = "BIDIRECTIONAL"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortDirectionINPUT captures enum value "INPUT"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortDirectionINPUT string = "INPUT"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortDirectionOUTPUT captures enum value "OUTPUT"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortDirectionOUTPUT string = "OUTPUT"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortDirectionUNIDENTIFIEDORUNKNOWN captures enum value "UNIDENTIFIED_OR_UNKNOWN"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortDirectionUNIDENTIFIEDORUNKNOWN string = "UNIDENTIFIED_OR_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateLinkPortDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLinkPortDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateLinkPortDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.LinkPortDirection) { // not required
		return nil
	}

	// value enum
	if err := m.validateLinkPortDirectionEnum("link-port-direction", "body", *m.LinkPortDirection); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLinkPortRolePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SYMMETRIC","ROOT","LEAF","TRUNK","UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLinkPortRolePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLinkPortRolePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortRoleSYMMETRIC captures enum value "SYMMETRIC"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortRoleSYMMETRIC string = "SYMMETRIC"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortRoleROOT captures enum value "ROOT"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortRoleROOT string = "ROOT"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortRoleLEAF captures enum value "LEAF"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortRoleLEAF string = "LEAF"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortRoleTRUNK captures enum value "TRUNK"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortRoleTRUNK string = "TRUNK"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortRoleUNKNOWN captures enum value "UNKNOWN"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0LinkPortRoleUNKNOWN string = "UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateLinkPortRoleEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeLinkPortRolePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateLinkPortRole(formats strfmt.Registry) error {

	if swag.IsZero(m.LinkPortRole) { // not required
		return nil
	}

	// value enum
	if err := m.validateLinkPortRoleEnum("link-port-role", "body", *m.LinkPortRole); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateMappedServiceInterfacePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.MappedServiceInterfacePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.MappedServiceInterfacePoint); i++ {
		if swag.IsZero(m.MappedServiceInterfacePoint[i]) { // not required
			continue
		}

		if m.MappedServiceInterfacePoint[i] != nil {
			if err := m.MappedServiceInterfacePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mapped-service-interface-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeOperationalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DISABLED","ENABLED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeOperationalStatePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeOperationalStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0OperationalStateDISABLED captures enum value "DISABLED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0OperationalStateDISABLED string = "DISABLED"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0OperationalStateENABLED captures enum value "ENABLED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0OperationalStateENABLED string = "ENABLED"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateOperationalStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeOperationalStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateOperationalState(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationalStateEnum("operational-state", "body", *m.OperationalState); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeTerminationDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BIDIRECTIONAL","SINK","SOURCE","UNDEFINED_OR_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeTerminationDirectionPropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeTerminationDirectionPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationDirectionBIDIRECTIONAL captures enum value "BIDIRECTIONAL"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationDirectionBIDIRECTIONAL string = "BIDIRECTIONAL"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationDirectionSINK captures enum value "SINK"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationDirectionSINK string = "SINK"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationDirectionSOURCE captures enum value "SOURCE"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationDirectionSOURCE string = "SOURCE"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationDirectionUNDEFINEDORUNKNOWN captures enum value "UNDEFINED_OR_UNKNOWN"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationDirectionUNDEFINEDORUNKNOWN string = "UNDEFINED_OR_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateTerminationDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeTerminationDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateTerminationDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.TerminationDirection) { // not required
		return nil
	}

	// value enum
	if err := m.validateTerminationDirectionEnum("termination-direction", "body", *m.TerminationDirection); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeTerminationStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LP_CAN_NEVER_TERMINATE","LT_NOT_TERMINATED","TERMINATED_SERVER_TO_CLIENT_FLOW","TERMINATED_CLIENT_TO_SERVER_FLOW","TERMINATED_BIDIRECTIONAL","LT_PERMENANTLY_TERMINATED","TERMINATION_STATE_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeTerminationStatePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeTerminationStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateLPCANNEVERTERMINATE captures enum value "LP_CAN_NEVER_TERMINATE"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateLPCANNEVERTERMINATE string = "LP_CAN_NEVER_TERMINATE"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateLTNOTTERMINATED captures enum value "LT_NOT_TERMINATED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateLTNOTTERMINATED string = "LT_NOT_TERMINATED"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateTERMINATEDSERVERTOCLIENTFLOW captures enum value "TERMINATED_SERVER_TO_CLIENT_FLOW"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateTERMINATEDSERVERTOCLIENTFLOW string = "TERMINATED_SERVER_TO_CLIENT_FLOW"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateTERMINATEDCLIENTTOSERVERFLOW captures enum value "TERMINATED_CLIENT_TO_SERVER_FLOW"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateTERMINATEDCLIENTTOSERVERFLOW string = "TERMINATED_CLIENT_TO_SERVER_FLOW"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateTERMINATEDBIDIRECTIONAL captures enum value "TERMINATED_BIDIRECTIONAL"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateTERMINATEDBIDIRECTIONAL string = "TERMINATED_BIDIRECTIONAL"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateLTPERMENANTLYTERMINATED captures enum value "LT_PERMENANTLY_TERMINATED"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateLTPERMENANTLYTERMINATED string = "LT_PERMENANTLY_TERMINATED"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateTERMINATIONSTATEUNKNOWN captures enum value "TERMINATION_STATE_UNKNOWN"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TerminationStateTERMINATIONSTATEUNKNOWN string = "TERMINATION_STATE_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateTerminationStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TypeTerminationStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateTerminationState(formats strfmt.Registry) error {

	if swag.IsZero(m.TerminationState) { // not required
		return nil
	}

	// value enum
	if err := m.validateTerminationStateEnum("termination-state", "body", *m.TerminationState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AggregatedNodeEdgePointItems0 data tapi topology get node details post output tapi topology node node edge point items0 aggregated node edge point items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AggregatedNodeEdgePointItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AggregatedNodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node edge point items0 aggregated node edge point items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AggregatedNodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AggregatedNodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AggregatedNodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AggregatedNodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacity
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node edge point items0 available capacity
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSize
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node edge point items0 available capacity total size
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCepLayerProtocolItems0 data tapi topology get node details post output tapi topology node node edge point items0 available cep layer protocol items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCepLayerProtocolItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCepLayerProtocolItems0 struct {

	// none (leaf)
	LayerProtocolQualifier string `json:"layer-protocol-qualifier,omitempty"`

	// none (leaf)
	NumberOfCepInstances uint64 `json:"number-of-cep-instances,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node edge point items0 available cep layer protocol items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCepLayerProtocolItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCepLayerProtocolItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCepLayerProtocolItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0AvailableCepLayerProtocolItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0MappedServiceInterfacePointItems0 data tapi topology get node details post output tapi topology node node edge point items0 mapped service interface point items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0MappedServiceInterfacePointItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0MappedServiceInterfacePointItems0 struct {

	// none (leaf)
	ServiceInterfacePointUUID string `json:"service-interface-point-uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node edge point items0 mapped service interface point items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0MappedServiceInterfacePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0MappedServiceInterfacePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0MappedServiceInterfacePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0MappedServiceInterfacePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0NameItems0 data tapi topology get node details post output tapi topology node node edge point items0 name items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0NameItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node edge point items0 name items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacity
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node edge point items0 total potential capacity
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node edge point items0 total potential capacity total size
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeEdgePointItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0 data tapi topology get node details post output tapi topology node node rule group items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0 struct {

	// available capacity
	AvailableCapacity *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// none (list)
	ComposedRuleGroup []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0ComposedRuleGroupItems0 `json:"composed-rule-group"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0CostCharacteristicItems0 `json:"cost-characteristic"`

	// none (list)
	InterRuleGroup []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0 `json:"inter-rule-group"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0LatencyCharacteristicItems0 `json:"latency-characteristic"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NameItems0 `json:"name"`

	// none (list)
	NodeEdgePoint []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NodeEdgePointItems0 `json:"node-edge-point"`

	// A list of risk characteristics for consideration in an analysis of shared risk. Each element of the list represents a specific risk consideration. (list)
	RiskCharacteristic []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RiskCharacteristicItems0 `json:"risk-characteristic"`

	// none (list)
	Rule []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0 `json:"rule"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComposedRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRiskCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) validateComposedRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.ComposedRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.ComposedRuleGroup); i++ {
		if swag.IsZero(m.ComposedRuleGroup[i]) { // not required
			continue
		}

		if m.ComposedRuleGroup[i] != nil {
			if err := m.ComposedRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("composed-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) validateInterRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.InterRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.InterRuleGroup); i++ {
		if swag.IsZero(m.InterRuleGroup[i]) { // not required
			continue
		}

		if m.InterRuleGroup[i] != nil {
			if err := m.InterRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inter-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) validateNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeEdgePoint); i++ {
		if swag.IsZero(m.NodeEdgePoint[i]) { // not required
			continue
		}

		if m.NodeEdgePoint[i] != nil {
			if err := m.NodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) validateRiskCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.RiskCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.RiskCharacteristic); i++ {
		if swag.IsZero(m.RiskCharacteristic[i]) { // not required
			continue
		}

		if m.RiskCharacteristic[i] != nil {
			if err := m.RiskCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("risk-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) validateRule(formats strfmt.Registry) error {

	if swag.IsZero(m.Rule) { // not required
		return nil
	}

	for i := 0; i < len(m.Rule); i++ {
		if swag.IsZero(m.Rule[i]) { // not required
			continue
		}

		if m.Rule[i] != nil {
			if err := m.Rule[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rule" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacity
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 available capacity
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSize
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 available capacity total size
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0ComposedRuleGroupItems0 data tapi topology get node details post output tapi topology node node rule group items0 composed rule group items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0ComposedRuleGroupItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0ComposedRuleGroupItems0 struct {

	// none (leaf)
	NodeRuleGroupUUID string `json:"node-rule-group-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 composed rule group items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0ComposedRuleGroupItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0ComposedRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0ComposedRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0ComposedRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0CostCharacteristicItems0 data tapi topology get node details post output tapi topology node node rule group items0 cost characteristic items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0CostCharacteristicItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0CostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 cost characteristic items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0CostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0CostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0CostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0CostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0 data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0 struct {

	// none (list)
	AssociatedNodeRuleGroup []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0 `json:"associated-node-rule-group"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0 `json:"cost-characteristic"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0 `json:"latency-characteristic"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0NameItems0 `json:"name"`

	// A list of risk characteristics for consideration in an analysis of shared risk. Each element of the list represents a specific risk consideration. (list)
	RiskCharacteristic []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0 `json:"risk-characteristic"`

	// none (list)
	Rule []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0 `json:"rule"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssociatedNodeRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRiskCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) validateAssociatedNodeRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.AssociatedNodeRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.AssociatedNodeRuleGroup); i++ {
		if swag.IsZero(m.AssociatedNodeRuleGroup[i]) { // not required
			continue
		}

		if m.AssociatedNodeRuleGroup[i] != nil {
			if err := m.AssociatedNodeRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("associated-node-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) validateRiskCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.RiskCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.RiskCharacteristic); i++ {
		if swag.IsZero(m.RiskCharacteristic[i]) { // not required
			continue
		}

		if m.RiskCharacteristic[i] != nil {
			if err := m.RiskCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("risk-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) validateRule(formats strfmt.Registry) error {

	if swag.IsZero(m.Rule) { // not required
		return nil
	}

	for i := 0; i < len(m.Rule); i++ {
		if swag.IsZero(m.Rule[i]) { // not required
			continue
		}

		if m.Rule[i] != nil {
			if err := m.Rule[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rule" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0 data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 associated node rule group items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0 struct {

	// none (leaf)
	NodeRuleGroupUUID string `json:"node-rule-group-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 associated node rule group items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 available capacity
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 available capacity total size
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0 data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 cost characteristic items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 cost characteristic items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0 data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 latency characteristic items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 latency characteristic items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0NameItems0 data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 name items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0NameItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 name items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0 data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 risk characteristic items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0 struct {

	// The name of the risk characteristic. The characteristic may be related to a specific degree of closeness.
	// For example a particular characteristic may apply to failures that are localized (e.g. to one side of a road) where as another characteristic may relate to failures that have a broader impact (e.g. both sides of a road that crosses a bridge).
	// Depending upon the importance of the traffic being routed different risk characteristics will be evaluated. (leaf)
	RiskCharacteristicName string `json:"risk-characteristic-name,omitempty"`

	// risk identifier list
	RiskIdentifierList []string `json:"risk-identifier-list"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 risk characteristic items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0 data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 rule items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0 struct {

	// none (leaf)
	// Enum: [MAY_FORWARD_ACROSS_GROUP MUST_FORWARD_ACROSS_GROUP CANNOT_FORWARD_ACROSS_GROUP NO_STATEMENT_ON_FORWARDING]
	ForwardingRule *string `json:"forwarding-rule,omitempty"`

	// none (leaf)
	LocalID string `json:"local-id,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0 `json:"name"`

	// none (leaf)
	OverridePriority uint64 `json:"override-priority,omitempty"`

	// none (leaf)
	// Enum: [FORWARDING CAPACITY COST TIMING RISK GROUPING]
	RuleType *string `json:"rule-type,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 rule items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateForwardingRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRuleType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MAY_FORWARD_ACROSS_GROUP","MUST_FORWARD_ACROSS_GROUP","CANNOT_FORWARD_ACROSS_GROUP","NO_STATEMENT_ON_FORWARDING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP captures enum value "MAY_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP string = "MAY_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP captures enum value "MUST_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP string = "MUST_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP captures enum value "CANNOT_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP string = "CANNOT_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING captures enum value "NO_STATEMENT_ON_FORWARDING"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING string = "NO_STATEMENT_ON_FORWARDING"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateForwardingRuleEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateForwardingRule(formats strfmt.Registry) error {

	if swag.IsZero(m.ForwardingRule) { // not required
		return nil
	}

	// value enum
	if err := m.validateForwardingRuleEnum("forwarding-rule", "body", *m.ForwardingRule); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FORWARDING","CAPACITY","COST","TIMING","RISK","GROUPING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeFORWARDING captures enum value "FORWARDING"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeFORWARDING string = "FORWARDING"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCAPACITY captures enum value "CAPACITY"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCAPACITY string = "CAPACITY"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCOST captures enum value "COST"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCOST string = "COST"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeTIMING captures enum value "TIMING"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeTIMING string = "TIMING"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeRISK captures enum value "RISK"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeRISK string = "RISK"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeGROUPING captures enum value "GROUPING"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeGROUPING string = "GROUPING"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateRuleTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateRuleType(formats strfmt.Registry) error {

	if swag.IsZero(m.RuleType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRuleTypeEnum("rule-type", "body", *m.RuleType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0 data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 rule items0 name items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 rule items0 name items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 total potential capacity
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 inter rule group items0 total potential capacity total size
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0LatencyCharacteristicItems0 data tapi topology get node details post output tapi topology node node rule group items0 latency characteristic items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0LatencyCharacteristicItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0LatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 latency characteristic items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0LatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0LatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0LatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0LatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NameItems0 data tapi topology get node details post output tapi topology node node rule group items0 name items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NameItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 name items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NodeEdgePointItems0 data tapi topology get node details post output tapi topology node node rule group items0 node edge point items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NodeEdgePointItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 node edge point items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0NodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RiskCharacteristicItems0 data tapi topology get node details post output tapi topology node node rule group items0 risk characteristic items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RiskCharacteristicItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RiskCharacteristicItems0 struct {

	// The name of the risk characteristic. The characteristic may be related to a specific degree of closeness.
	// For example a particular characteristic may apply to failures that are localized (e.g. to one side of a road) where as another characteristic may relate to failures that have a broader impact (e.g. both sides of a road that crosses a bridge).
	// Depending upon the importance of the traffic being routed different risk characteristics will be evaluated. (leaf)
	RiskCharacteristicName string `json:"risk-characteristic-name,omitempty"`

	// risk identifier list
	RiskIdentifierList []string `json:"risk-identifier-list"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 risk characteristic items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RiskCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RiskCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RiskCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RiskCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0 data tapi topology get node details post output tapi topology node node rule group items0 rule items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0 struct {

	// none (leaf)
	// Enum: [MAY_FORWARD_ACROSS_GROUP MUST_FORWARD_ACROSS_GROUP CANNOT_FORWARD_ACROSS_GROUP NO_STATEMENT_ON_FORWARDING]
	ForwardingRule *string `json:"forwarding-rule,omitempty"`

	// none (leaf)
	LocalID string `json:"local-id,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0NameItems0 `json:"name"`

	// none (leaf)
	OverridePriority uint64 `json:"override-priority,omitempty"`

	// none (leaf)
	// Enum: [FORWARDING CAPACITY COST TIMING RISK GROUPING]
	RuleType *string `json:"rule-type,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 rule items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateForwardingRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRuleType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MAY_FORWARD_ACROSS_GROUP","MUST_FORWARD_ACROSS_GROUP","CANNOT_FORWARD_ACROSS_GROUP","NO_STATEMENT_ON_FORWARDING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP captures enum value "MAY_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP string = "MAY_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP captures enum value "MUST_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP string = "MUST_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP captures enum value "CANNOT_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP string = "CANNOT_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING captures enum value "NO_STATEMENT_ON_FORWARDING"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING string = "NO_STATEMENT_ON_FORWARDING"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0) validateForwardingRuleEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0) validateForwardingRule(formats strfmt.Registry) error {

	if swag.IsZero(m.ForwardingRule) { // not required
		return nil
	}

	// value enum
	if err := m.validateForwardingRuleEnum("forwarding-rule", "body", *m.ForwardingRule); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FORWARDING","CAPACITY","COST","TIMING","RISK","GROUPING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeFORWARDING captures enum value "FORWARDING"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeFORWARDING string = "FORWARDING"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeCAPACITY captures enum value "CAPACITY"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeCAPACITY string = "CAPACITY"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeCOST captures enum value "COST"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeCOST string = "COST"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeTIMING captures enum value "TIMING"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeTIMING string = "TIMING"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeRISK captures enum value "RISK"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeRISK string = "RISK"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeGROUPING captures enum value "GROUPING"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0RuleTypeGROUPING string = "GROUPING"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0) validateRuleTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0) validateRuleType(formats strfmt.Registry) error {

	if swag.IsZero(m.RuleType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRuleTypeEnum("rule-type", "body", *m.RuleType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0NameItems0 data tapi topology get node details post output tapi topology node node rule group items0 rule items0 name items0
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0NameItems0
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 rule items0 name items0
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0RuleItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacity
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 total potential capacity
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node node rule group items0 total potential capacity total size
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeNodeRuleGroupItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacity
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node total potential capacity
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tapi-topology:node" + "." + "total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSize
type DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get node details post output tapi topology node total potential capacity total size
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("tapi-topology:node"+"."+"total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetNodeDetailsPostOutputTapiTopologyNodeTotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
