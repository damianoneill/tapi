// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataTapiTopologyGetTopologyDetailsPostOutput data tapi topology get topology details post output
// swagger:model data_tapi-topology_get-topology-details-post-output
type DataTapiTopologyGetTopologyDetailsPostOutput struct {

	// tapi topology topology
	TapiTopologyTopology *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology `json:"tapi-topology:topology,omitempty"`
}

// Validate validates this data tapi topology get topology details post output
func (m *DataTapiTopologyGetTopologyDetailsPostOutput) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTapiTopologyTopology(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutput) validateTapiTopologyTopology(formats strfmt.Registry) error {

	if swag.IsZero(m.TapiTopologyTopology) { // not required
		return nil
	}

	if m.TapiTopologyTopology != nil {
		if err := m.TapiTopologyTopology.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tapi-topology:topology")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutput) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutput) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutput
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology none (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology struct {

	// none (list)
	BoundaryNodeEdgePoint []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyBoundaryNodeEdgePointItems0 `json:"boundary-node-edge-point"`

	// layer protocol name
	LayerProtocolName []*string `json:"layer-protocol-name"`

	// none (list)
	Link []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0 `json:"link"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNameItems0 `json:"name"`

	// none (list)
	Node []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0 `json:"node"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBoundaryNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayerProtocolName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLink(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology) validateBoundaryNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.BoundaryNodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.BoundaryNodeEdgePoint); i++ {
		if swag.IsZero(m.BoundaryNodeEdgePoint[i]) { // not required
			continue
		}

		if m.BoundaryNodeEdgePoint[i] != nil {
			if err := m.BoundaryNodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:topology" + "." + "boundary-node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLayerProtocolNameItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODU","ETH","DSR","PHOTONIC_MEDIA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLayerProtocolNameItemsEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLayerProtocolNameItemsEnum, v)
	}
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology) validateLayerProtocolNameItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLayerProtocolNameItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology) validateLayerProtocolName(formats strfmt.Registry) error {

	if swag.IsZero(m.LayerProtocolName) { // not required
		return nil
	}

	for i := 0; i < len(m.LayerProtocolName); i++ {
		if swag.IsZero(m.LayerProtocolName[i]) { // not required
			continue
		}

		// value enum
		if err := m.validateLayerProtocolNameItemsEnum("tapi-topology:topology"+"."+"layer-protocol-name"+"."+strconv.Itoa(i), "body", *m.LayerProtocolName[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology) validateLink(formats strfmt.Registry) error {

	if swag.IsZero(m.Link) { // not required
		return nil
	}

	for i := 0; i < len(m.Link); i++ {
		if swag.IsZero(m.Link[i]) { // not required
			continue
		}

		if m.Link[i] != nil {
			if err := m.Link[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:topology" + "." + "link" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:topology" + "." + "name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology) validateNode(formats strfmt.Registry) error {

	if swag.IsZero(m.Node) { // not required
		return nil
	}

	for i := 0; i < len(m.Node); i++ {
		if swag.IsZero(m.Node[i]) { // not required
			continue
		}

		if m.Node[i] != nil {
			if err := m.Node[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tapi-topology:topology" + "." + "node" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopology
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyBoundaryNodeEdgePointItems0 data tapi topology get topology details post output tapi topology topology boundary node edge point items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyBoundaryNodeEdgePointItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyBoundaryNodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology boundary node edge point items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyBoundaryNodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyBoundaryNodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyBoundaryNodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyBoundaryNodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0 data tapi topology get topology details post output tapi topology topology link items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0 struct {

	// none (leaf)
	// Enum: [LOCKED UNLOCKED]
	AdministrativeState *string `json:"administrative-state,omitempty"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0CostCharacteristicItems0 `json:"cost-characteristic"`

	// Describes the degree to which packets will be delivered out of sequence.
	// Does not apply to TDM as the TDM protocols maintain strict order. (leaf)
	DeliveryOrderCharacteristic string `json:"delivery-order-characteristic,omitempty"`

	// The directionality of the Link.
	// Is applicable to simple Links where all LinkEnds are BIDIRECTIONAL (the Link will be BIDIRECTIONAL) or UNIDIRECTIONAL (the Link will be UNIDIRECTIONAL).
	// Is not present in more complex cases. (leaf)
	// Enum: [BIDIRECTIONAL UNIDIRECTIONAL UNDEFINED_OR_UNKNOWN]
	Direction *string `json:"direction,omitempty"`

	// Describes the degree to which the signal propagated can be errored.
	// Applies to TDM systems as the errored signal will be propagated and not packet as errored packets will be discarded. (leaf)
	ErrorCharacteristic string `json:"error-characteristic,omitempty"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LatencyCharacteristicItems0 `json:"latency-characteristic"`

	// layer protocol name
	LayerProtocolName []*string `json:"layer-protocol-name"`

	// none (leaf)
	// Enum: [PLANNED POTENTIAL_AVAILABLE POTENTIAL_BUSY INSTALLED PENDING_REMOVAL]
	LifecycleState *string `json:"lifecycle-state,omitempty"`

	// Describes the acceptable characteristic of lost packets where loss may result from discard due to errors or overflow.
	// Applies to packet systems and not TDM (as for TDM errored signals are propagated unless grossly errored and overflow/underflow turns into timing slips). (leaf)
	LossCharacteristic string `json:"loss-characteristic,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NameItems0 `json:"name"`

	// none (list)
	NodeEdgePoint []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NodeEdgePointItems0 `json:"node-edge-point"`

	// none (leaf)
	// Enum: [DISABLED ENABLED]
	OperationalState *string `json:"operational-state,omitempty"`

	// none (leaf)
	// Enum: [NO_PROTECTION ONE_PLUS_ONE_PROTECTION ONE_FOR_ONE_PROTECTION ONE_FOR_N_PROTECTION M_FOR_N_PROTECTION ONE_FOR_ONE_BY_N]
	ProtectionType *string `json:"protection-type,omitempty"`

	// Primarily applies to packet systems where a packet may be delivered more than once (in fault recovery for example).
	// It can also apply to TDM where several frames may be received twice due to switching in a system with a large differential propagation delay. (leaf)
	RepeatDeliveryCharacteristic string `json:"repeat-delivery-characteristic,omitempty"`

	// none (leaf)
	// Enum: [PER_DOMAIN_RESTORATION END_TO_END_RESTORATION NA DYNAMIC_RESTORATION PRE_COMPUTED_RESTORATION]
	RestorationPolicy *string `json:"restoration-policy,omitempty"`

	// A list of risk characteristics for consideration in an analysis of shared risk. Each element of the list represents a specific risk consideration. (list)
	RiskCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RiskCharacteristicItems0 `json:"risk-characteristic"`

	// Describes the effect of any server integrity enhancement process on the characteristics of the TopologicalEntity. (leaf)
	ServerIntegrityProcessCharacteristic string `json:"server-integrity-process-characteristic,omitempty"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// transitioned layer protocol name
	TransitionedLayerProtocolName []string `json:"transitioned-layer-protocol-name"`

	// Describes the duration for which there may be no valid signal propagated. (leaf)
	UnavailableTimeCharacteristic string `json:"unavailable-time-characteristic,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`

	// Provides details of the specific validation mechanism(s) used to confirm the presence of an intended topologicalEntity. (list)
	ValidationMechanism []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ValidationMechanismItems0 `json:"validation-mechanism"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdministrativeState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayerProtocolName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLifecycleState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtectionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestorationPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRiskCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationMechanism(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeAdministrativeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LOCKED","UNLOCKED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeAdministrativeStatePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeAdministrativeStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AdministrativeStateLOCKED captures enum value "LOCKED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AdministrativeStateLOCKED string = "LOCKED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AdministrativeStateUNLOCKED captures enum value "UNLOCKED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AdministrativeStateUNLOCKED string = "UNLOCKED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateAdministrativeStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeAdministrativeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateAdministrativeState(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdministrativeStateEnum("administrative-state", "body", *m.AdministrativeState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BIDIRECTIONAL","UNIDIRECTIONAL","UNDEFINED_OR_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeDirectionPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeDirectionPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0DirectionBIDIRECTIONAL captures enum value "BIDIRECTIONAL"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0DirectionBIDIRECTIONAL string = "BIDIRECTIONAL"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0DirectionUNIDIRECTIONAL captures enum value "UNIDIRECTIONAL"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0DirectionUNIDIRECTIONAL string = "UNIDIRECTIONAL"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0DirectionUNDEFINEDORUNKNOWN captures enum value "UNDEFINED_OR_UNKNOWN"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0DirectionUNDEFINEDORUNKNOWN string = "UNDEFINED_OR_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.Direction) { // not required
		return nil
	}

	// value enum
	if err := m.validateDirectionEnum("direction", "body", *m.Direction); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LayerProtocolNameItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODU","ETH","DSR","PHOTONIC_MEDIA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LayerProtocolNameItemsEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LayerProtocolNameItemsEnum, v)
	}
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateLayerProtocolNameItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LayerProtocolNameItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateLayerProtocolName(formats strfmt.Registry) error {

	if swag.IsZero(m.LayerProtocolName) { // not required
		return nil
	}

	for i := 0; i < len(m.LayerProtocolName); i++ {
		if swag.IsZero(m.LayerProtocolName[i]) { // not required
			continue
		}

		// value enum
		if err := m.validateLayerProtocolNameItemsEnum("layer-protocol-name"+"."+strconv.Itoa(i), "body", *m.LayerProtocolName[i]); err != nil {
			return err
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeLifecycleStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PLANNED","POTENTIAL_AVAILABLE","POTENTIAL_BUSY","INSTALLED","PENDING_REMOVAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeLifecycleStatePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeLifecycleStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LifecycleStatePLANNED captures enum value "PLANNED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LifecycleStatePLANNED string = "PLANNED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LifecycleStatePOTENTIALAVAILABLE captures enum value "POTENTIAL_AVAILABLE"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LifecycleStatePOTENTIALAVAILABLE string = "POTENTIAL_AVAILABLE"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LifecycleStatePOTENTIALBUSY captures enum value "POTENTIAL_BUSY"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LifecycleStatePOTENTIALBUSY string = "POTENTIAL_BUSY"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LifecycleStateINSTALLED captures enum value "INSTALLED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LifecycleStateINSTALLED string = "INSTALLED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LifecycleStatePENDINGREMOVAL captures enum value "PENDING_REMOVAL"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LifecycleStatePENDINGREMOVAL string = "PENDING_REMOVAL"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateLifecycleStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeLifecycleStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateLifecycleState(formats strfmt.Registry) error {

	if swag.IsZero(m.LifecycleState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLifecycleStateEnum("lifecycle-state", "body", *m.LifecycleState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeEdgePoint); i++ {
		if swag.IsZero(m.NodeEdgePoint[i]) { // not required
			continue
		}

		if m.NodeEdgePoint[i] != nil {
			if err := m.NodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeOperationalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DISABLED","ENABLED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeOperationalStatePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeOperationalStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0OperationalStateDISABLED captures enum value "DISABLED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0OperationalStateDISABLED string = "DISABLED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0OperationalStateENABLED captures enum value "ENABLED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0OperationalStateENABLED string = "ENABLED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateOperationalStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeOperationalStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateOperationalState(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationalStateEnum("operational-state", "body", *m.OperationalState); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeProtectionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NO_PROTECTION","ONE_PLUS_ONE_PROTECTION","ONE_FOR_ONE_PROTECTION","ONE_FOR_N_PROTECTION","M_FOR_N_PROTECTION","ONE_FOR_ONE_BY_N"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeProtectionTypePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeProtectionTypePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeNOPROTECTION captures enum value "NO_PROTECTION"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeNOPROTECTION string = "NO_PROTECTION"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeONEPLUSONEPROTECTION captures enum value "ONE_PLUS_ONE_PROTECTION"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeONEPLUSONEPROTECTION string = "ONE_PLUS_ONE_PROTECTION"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeONEFORONEPROTECTION captures enum value "ONE_FOR_ONE_PROTECTION"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeONEFORONEPROTECTION string = "ONE_FOR_ONE_PROTECTION"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeONEFORNPROTECTION captures enum value "ONE_FOR_N_PROTECTION"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeONEFORNPROTECTION string = "ONE_FOR_N_PROTECTION"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeMFORNPROTECTION captures enum value "M_FOR_N_PROTECTION"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeMFORNPROTECTION string = "M_FOR_N_PROTECTION"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeONEFORONEBYN captures enum value "ONE_FOR_ONE_BY_N"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ProtectionTypeONEFORONEBYN string = "ONE_FOR_ONE_BY_N"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateProtectionTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeProtectionTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateProtectionType(formats strfmt.Registry) error {

	if swag.IsZero(m.ProtectionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtectionTypeEnum("protection-type", "body", *m.ProtectionType); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeRestorationPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PER_DOMAIN_RESTORATION","END_TO_END_RESTORATION","NA","DYNAMIC_RESTORATION","PRE_COMPUTED_RESTORATION"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeRestorationPolicyPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeRestorationPolicyPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RestorationPolicyPERDOMAINRESTORATION captures enum value "PER_DOMAIN_RESTORATION"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RestorationPolicyPERDOMAINRESTORATION string = "PER_DOMAIN_RESTORATION"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RestorationPolicyENDTOENDRESTORATION captures enum value "END_TO_END_RESTORATION"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RestorationPolicyENDTOENDRESTORATION string = "END_TO_END_RESTORATION"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RestorationPolicyNA captures enum value "NA"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RestorationPolicyNA string = "NA"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RestorationPolicyDYNAMICRESTORATION captures enum value "DYNAMIC_RESTORATION"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RestorationPolicyDYNAMICRESTORATION string = "DYNAMIC_RESTORATION"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RestorationPolicyPRECOMPUTEDRESTORATION captures enum value "PRE_COMPUTED_RESTORATION"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RestorationPolicyPRECOMPUTEDRESTORATION string = "PRE_COMPUTED_RESTORATION"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateRestorationPolicyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TypeRestorationPolicyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateRestorationPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.RestorationPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateRestorationPolicyEnum("restoration-policy", "body", *m.RestorationPolicy); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateRiskCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.RiskCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.RiskCharacteristic); i++ {
		if swag.IsZero(m.RiskCharacteristic[i]) { // not required
			continue
		}

		if m.RiskCharacteristic[i] != nil {
			if err := m.RiskCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("risk-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) validateValidationMechanism(formats strfmt.Registry) error {

	if swag.IsZero(m.ValidationMechanism) { // not required
		return nil
	}

	for i := 0; i < len(m.ValidationMechanism); i++ {
		if swag.IsZero(m.ValidationMechanism[i]) { // not required
			continue
		}

		if m.ValidationMechanism[i] != nil {
			if err := m.ValidationMechanism[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validation-mechanism" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacity
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0 available capacity
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSize
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0 available capacity total size
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0CostCharacteristicItems0 data tapi topology get topology details post output tapi topology topology link items0 cost characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0CostCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0CostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0 cost characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0CostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0CostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0CostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0CostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LatencyCharacteristicItems0 data tapi topology get topology details post output tapi topology topology link items0 latency characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LatencyCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0 latency characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0LatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NameItems0 data tapi topology get topology details post output tapi topology topology link items0 name items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NameItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0 name items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NodeEdgePointItems0 data tapi topology get topology details post output tapi topology topology link items0 node edge point items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NodeEdgePointItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0 node edge point items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0NodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RiskCharacteristicItems0 data tapi topology get topology details post output tapi topology topology link items0 risk characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RiskCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RiskCharacteristicItems0 struct {

	// The name of the risk characteristic. The characteristic may be related to a specific degree of closeness.
	// For example a particular characteristic may apply to failures that are localized (e.g. to one side of a road) where as another characteristic may relate to failures that have a broader impact (e.g. both sides of a road that crosses a bridge).
	// Depending upon the importance of the traffic being routed different risk characteristics will be evaluated. (leaf)
	RiskCharacteristicName string `json:"risk-characteristic-name,omitempty"`

	// risk identifier list
	RiskIdentifierList []string `json:"risk-identifier-list"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0 risk characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RiskCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RiskCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RiskCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0RiskCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacity
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0 total potential capacity
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0 total potential capacity total size
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ValidationMechanismItems0 data tapi topology get topology details post output tapi topology topology link items0 validation mechanism items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ValidationMechanismItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ValidationMechanismItems0 struct {

	// State of validatiion (leaf)
	LayerProtocolAdjacencyValidated string `json:"layer-protocol-adjacency-validated,omitempty"`

	// Name of mechanism used to validate adjacency (leaf)
	ValidationMechanism string `json:"validation-mechanism,omitempty"`

	// Quality of validation (i.e. how likely is the stated validation to be invalid) (leaf)
	ValidationRobustness string `json:"validation-robustness,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology link items0 validation mechanism items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ValidationMechanismItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ValidationMechanismItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ValidationMechanismItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyLinkItems0ValidationMechanismItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNameItems0 data tapi topology get topology details post output tapi topology topology name items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNameItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology name items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0 data tapi topology get topology details post output tapi topology topology node items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0 struct {

	// none (leaf)
	// Enum: [LOCKED UNLOCKED]
	AdministrativeState *string `json:"administrative-state,omitempty"`

	// none (list)
	AggregatedNodeEdgePoint []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AggregatedNodeEdgePointItems0 `json:"aggregated-node-edge-point"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0CostCharacteristicItems0 `json:"cost-characteristic"`

	// Describes the degree to which packets will be delivered out of sequence.
	// Does not apply to TDM as the TDM protocols maintain strict order. (leaf)
	DeliveryOrderCharacteristic string `json:"delivery-order-characteristic,omitempty"`

	// encap topology
	EncapTopology *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0EncapTopology `json:"encap-topology,omitempty"`

	// Describes the degree to which the signal propagated can be errored.
	// Applies to TDM systems as the errored signal will be propagated and not packet as errored packets will be discarded. (leaf)
	ErrorCharacteristic string `json:"error-characteristic,omitempty"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LatencyCharacteristicItems0 `json:"latency-characteristic"`

	// layer protocol name
	LayerProtocolName []*string `json:"layer-protocol-name"`

	// none (leaf)
	// Enum: [PLANNED POTENTIAL_AVAILABLE POTENTIAL_BUSY INSTALLED PENDING_REMOVAL]
	LifecycleState *string `json:"lifecycle-state,omitempty"`

	// Describes the acceptable characteristic of lost packets where loss may result from discard due to errors or overflow.
	// Applies to packet systems and not TDM (as for TDM errored signals are propagated unless grossly errored and overflow/underflow turns into timing slips). (leaf)
	LossCharacteristic string `json:"loss-characteristic,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NameItems0 `json:"name"`

	// none (list)
	NodeEdgePoint []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0 `json:"node-edge-point"`

	// none (list)
	NodeRuleGroup []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0 `json:"node-rule-group"`

	// none (leaf)
	// Enum: [DISABLED ENABLED]
	OperationalState *string `json:"operational-state,omitempty"`

	// Primarily applies to packet systems where a packet may be delivered more than once (in fault recovery for example).
	// It can also apply to TDM where several frames may be received twice due to switching in a system with a large differential propagation delay. (leaf)
	RepeatDeliveryCharacteristic string `json:"repeat-delivery-characteristic,omitempty"`

	// Describes the effect of any server integrity enhancement process on the characteristics of the TopologicalEntity. (leaf)
	ServerIntegrityProcessCharacteristic string `json:"server-integrity-process-characteristic,omitempty"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// Describes the duration for which there may be no valid signal propagated. (leaf)
	UnavailableTimeCharacteristic string `json:"unavailable-time-characteristic,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdministrativeState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregatedNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncapTopology(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayerProtocolName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLifecycleState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeAdministrativeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LOCKED","UNLOCKED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeAdministrativeStatePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeAdministrativeStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AdministrativeStateLOCKED captures enum value "LOCKED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AdministrativeStateLOCKED string = "LOCKED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AdministrativeStateUNLOCKED captures enum value "UNLOCKED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AdministrativeStateUNLOCKED string = "UNLOCKED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateAdministrativeStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeAdministrativeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateAdministrativeState(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdministrativeStateEnum("administrative-state", "body", *m.AdministrativeState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateAggregatedNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.AggregatedNodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.AggregatedNodeEdgePoint); i++ {
		if swag.IsZero(m.AggregatedNodeEdgePoint[i]) { // not required
			continue
		}

		if m.AggregatedNodeEdgePoint[i] != nil {
			if err := m.AggregatedNodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregated-node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateEncapTopology(formats strfmt.Registry) error {

	if swag.IsZero(m.EncapTopology) { // not required
		return nil
	}

	if m.EncapTopology != nil {
		if err := m.EncapTopology.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encap-topology")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LayerProtocolNameItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODU","ETH","DSR","PHOTONIC_MEDIA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LayerProtocolNameItemsEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LayerProtocolNameItemsEnum, v)
	}
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateLayerProtocolNameItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LayerProtocolNameItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateLayerProtocolName(formats strfmt.Registry) error {

	if swag.IsZero(m.LayerProtocolName) { // not required
		return nil
	}

	for i := 0; i < len(m.LayerProtocolName); i++ {
		if swag.IsZero(m.LayerProtocolName[i]) { // not required
			continue
		}

		// value enum
		if err := m.validateLayerProtocolNameItemsEnum("layer-protocol-name"+"."+strconv.Itoa(i), "body", *m.LayerProtocolName[i]); err != nil {
			return err
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeLifecycleStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PLANNED","POTENTIAL_AVAILABLE","POTENTIAL_BUSY","INSTALLED","PENDING_REMOVAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeLifecycleStatePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeLifecycleStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LifecycleStatePLANNED captures enum value "PLANNED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LifecycleStatePLANNED string = "PLANNED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LifecycleStatePOTENTIALAVAILABLE captures enum value "POTENTIAL_AVAILABLE"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LifecycleStatePOTENTIALAVAILABLE string = "POTENTIAL_AVAILABLE"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LifecycleStatePOTENTIALBUSY captures enum value "POTENTIAL_BUSY"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LifecycleStatePOTENTIALBUSY string = "POTENTIAL_BUSY"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LifecycleStateINSTALLED captures enum value "INSTALLED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LifecycleStateINSTALLED string = "INSTALLED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LifecycleStatePENDINGREMOVAL captures enum value "PENDING_REMOVAL"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LifecycleStatePENDINGREMOVAL string = "PENDING_REMOVAL"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateLifecycleStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeLifecycleStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateLifecycleState(formats strfmt.Registry) error {

	if swag.IsZero(m.LifecycleState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLifecycleStateEnum("lifecycle-state", "body", *m.LifecycleState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeEdgePoint); i++ {
		if swag.IsZero(m.NodeEdgePoint[i]) { // not required
			continue
		}

		if m.NodeEdgePoint[i] != nil {
			if err := m.NodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateNodeRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeRuleGroup); i++ {
		if swag.IsZero(m.NodeRuleGroup[i]) { // not required
			continue
		}

		if m.NodeRuleGroup[i] != nil {
			if err := m.NodeRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeOperationalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DISABLED","ENABLED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeOperationalStatePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeOperationalStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0OperationalStateDISABLED captures enum value "DISABLED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0OperationalStateDISABLED string = "DISABLED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0OperationalStateENABLED captures enum value "ENABLED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0OperationalStateENABLED string = "ENABLED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateOperationalStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TypeOperationalStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateOperationalState(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationalStateEnum("operational-state", "body", *m.OperationalState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AggregatedNodeEdgePointItems0 data tapi topology get topology details post output tapi topology topology node items0 aggregated node edge point items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AggregatedNodeEdgePointItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AggregatedNodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 aggregated node edge point items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AggregatedNodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AggregatedNodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AggregatedNodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AggregatedNodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacity
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 available capacity
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSize
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 available capacity total size
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0CostCharacteristicItems0 data tapi topology get topology details post output tapi topology topology node items0 cost characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0CostCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0CostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 cost characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0CostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0CostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0CostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0CostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0EncapTopology none (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0EncapTopology
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0EncapTopology struct {

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 encap topology
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0EncapTopology) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0EncapTopology) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0EncapTopology) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0EncapTopology
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LatencyCharacteristicItems0 data tapi topology get topology details post output tapi topology topology node items0 latency characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LatencyCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 latency characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0LatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NameItems0 data tapi topology get topology details post output tapi topology topology node items0 name items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NameItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 name items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0 data tapi topology get topology details post output tapi topology topology node items0 node edge point items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0 struct {

	// none (leaf)
	// Enum: [LOCKED UNLOCKED]
	AdministrativeState *string `json:"administrative-state,omitempty"`

	// none (list)
	AggregatedNodeEdgePoint []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0 `json:"aggregated-node-edge-point"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// none (list)
	AvailableCepLayerProtocol []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0 `json:"available-cep-layer-protocol"`

	// none (leaf)
	// Enum: [ODU ETH DSR PHOTONIC_MEDIA]
	LayerProtocolName *string `json:"layer-protocol-name,omitempty"`

	// none (leaf)
	// Enum: [PLANNED POTENTIAL_AVAILABLE POTENTIAL_BUSY INSTALLED PENDING_REMOVAL]
	LifecycleState *string `json:"lifecycle-state,omitempty"`

	// The orientation of defined flow at the LinkEnd. (leaf)
	// Enum: [BIDIRECTIONAL INPUT OUTPUT UNIDENTIFIED_OR_UNKNOWN]
	LinkPortDirection *string `json:"link-port-direction,omitempty"`

	// Each LinkEnd of the Link has a role (e.g., symmetric, hub, spoke, leaf, root)  in the context of the Link with respect to the Link function.  (leaf)
	// Enum: [SYMMETRIC ROOT LEAF TRUNK UNKNOWN]
	LinkPortRole *string `json:"link-port-role,omitempty"`

	// NodeEdgePoint mapped to more than ServiceInterfacePoint (slicing/virtualizing) or a ServiceInterfacePoint mapped to more than one NodeEdgePoint (load balancing/Resilience) should be considered experimental (list)
	MappedServiceInterfacePoint []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0 `json:"mapped-service-interface-point"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0NameItems0 `json:"name"`

	// none (leaf)
	// Enum: [DISABLED ENABLED]
	OperationalState *string `json:"operational-state,omitempty"`

	// The overall directionality of the LP.
	// - A BIDIRECTIONAL LP will have some SINK and/or SOURCE flowss.
	// - A SINK LP can only contain elements with SINK flows or CONTRA_DIRECTION_SOURCE flows
	// - A SOURCE LP can only contain SOURCE flows or CONTRA_DIRECTION_SINK flows (leaf)
	// Enum: [BIDIRECTIONAL SINK SOURCE UNDEFINED_OR_UNKNOWN]
	TerminationDirection *string `json:"termination-direction,omitempty"`

	// Indicates whether the layer is terminated and if so how. (leaf)
	// Enum: [LP_CAN_NEVER_TERMINATE LT_NOT_TERMINATED TERMINATED_SERVER_TO_CLIENT_FLOW TERMINATED_CLIENT_TO_SERVER_FLOW TERMINATED_BIDIRECTIONAL LT_PERMENANTLY_TERMINATED TERMINATION_STATE_UNKNOWN]
	TerminationState *string `json:"termination-state,omitempty"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node edge point items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdministrativeState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregatedNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCepLayerProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayerProtocolName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLifecycleState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkPortDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkPortRole(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMappedServiceInterfacePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTerminationDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTerminationState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeAdministrativeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LOCKED","UNLOCKED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeAdministrativeStatePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeAdministrativeStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AdministrativeStateLOCKED captures enum value "LOCKED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AdministrativeStateLOCKED string = "LOCKED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AdministrativeStateUNLOCKED captures enum value "UNLOCKED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AdministrativeStateUNLOCKED string = "UNLOCKED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateAdministrativeStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeAdministrativeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateAdministrativeState(formats strfmt.Registry) error {

	if swag.IsZero(m.AdministrativeState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdministrativeStateEnum("administrative-state", "body", *m.AdministrativeState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateAggregatedNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.AggregatedNodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.AggregatedNodeEdgePoint); i++ {
		if swag.IsZero(m.AggregatedNodeEdgePoint[i]) { // not required
			continue
		}

		if m.AggregatedNodeEdgePoint[i] != nil {
			if err := m.AggregatedNodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aggregated-node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateAvailableCepLayerProtocol(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCepLayerProtocol) { // not required
		return nil
	}

	for i := 0; i < len(m.AvailableCepLayerProtocol); i++ {
		if swag.IsZero(m.AvailableCepLayerProtocol[i]) { // not required
			continue
		}

		if m.AvailableCepLayerProtocol[i] != nil {
			if err := m.AvailableCepLayerProtocol[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("available-cep-layer-protocol" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLayerProtocolNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ODU","ETH","DSR","PHOTONIC_MEDIA"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLayerProtocolNamePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLayerProtocolNamePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LayerProtocolNameODU captures enum value "ODU"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LayerProtocolNameODU string = "ODU"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LayerProtocolNameETH captures enum value "ETH"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LayerProtocolNameETH string = "ETH"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LayerProtocolNameDSR captures enum value "DSR"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LayerProtocolNameDSR string = "DSR"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LayerProtocolNamePHOTONICMEDIA captures enum value "PHOTONIC_MEDIA"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LayerProtocolNamePHOTONICMEDIA string = "PHOTONIC_MEDIA"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateLayerProtocolNameEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLayerProtocolNamePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateLayerProtocolName(formats strfmt.Registry) error {

	if swag.IsZero(m.LayerProtocolName) { // not required
		return nil
	}

	// value enum
	if err := m.validateLayerProtocolNameEnum("layer-protocol-name", "body", *m.LayerProtocolName); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLifecycleStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PLANNED","POTENTIAL_AVAILABLE","POTENTIAL_BUSY","INSTALLED","PENDING_REMOVAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLifecycleStatePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLifecycleStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LifecycleStatePLANNED captures enum value "PLANNED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LifecycleStatePLANNED string = "PLANNED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LifecycleStatePOTENTIALAVAILABLE captures enum value "POTENTIAL_AVAILABLE"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LifecycleStatePOTENTIALAVAILABLE string = "POTENTIAL_AVAILABLE"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LifecycleStatePOTENTIALBUSY captures enum value "POTENTIAL_BUSY"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LifecycleStatePOTENTIALBUSY string = "POTENTIAL_BUSY"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LifecycleStateINSTALLED captures enum value "INSTALLED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LifecycleStateINSTALLED string = "INSTALLED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LifecycleStatePENDINGREMOVAL captures enum value "PENDING_REMOVAL"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LifecycleStatePENDINGREMOVAL string = "PENDING_REMOVAL"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateLifecycleStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLifecycleStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateLifecycleState(formats strfmt.Registry) error {

	if swag.IsZero(m.LifecycleState) { // not required
		return nil
	}

	// value enum
	if err := m.validateLifecycleStateEnum("lifecycle-state", "body", *m.LifecycleState); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLinkPortDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BIDIRECTIONAL","INPUT","OUTPUT","UNIDENTIFIED_OR_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLinkPortDirectionPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLinkPortDirectionPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortDirectionBIDIRECTIONAL captures enum value "BIDIRECTIONAL"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortDirectionBIDIRECTIONAL string = "BIDIRECTIONAL"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortDirectionINPUT captures enum value "INPUT"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortDirectionINPUT string = "INPUT"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortDirectionOUTPUT captures enum value "OUTPUT"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortDirectionOUTPUT string = "OUTPUT"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortDirectionUNIDENTIFIEDORUNKNOWN captures enum value "UNIDENTIFIED_OR_UNKNOWN"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortDirectionUNIDENTIFIEDORUNKNOWN string = "UNIDENTIFIED_OR_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateLinkPortDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLinkPortDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateLinkPortDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.LinkPortDirection) { // not required
		return nil
	}

	// value enum
	if err := m.validateLinkPortDirectionEnum("link-port-direction", "body", *m.LinkPortDirection); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLinkPortRolePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SYMMETRIC","ROOT","LEAF","TRUNK","UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLinkPortRolePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLinkPortRolePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortRoleSYMMETRIC captures enum value "SYMMETRIC"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortRoleSYMMETRIC string = "SYMMETRIC"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortRoleROOT captures enum value "ROOT"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortRoleROOT string = "ROOT"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortRoleLEAF captures enum value "LEAF"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortRoleLEAF string = "LEAF"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortRoleTRUNK captures enum value "TRUNK"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortRoleTRUNK string = "TRUNK"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortRoleUNKNOWN captures enum value "UNKNOWN"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0LinkPortRoleUNKNOWN string = "UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateLinkPortRoleEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeLinkPortRolePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateLinkPortRole(formats strfmt.Registry) error {

	if swag.IsZero(m.LinkPortRole) { // not required
		return nil
	}

	// value enum
	if err := m.validateLinkPortRoleEnum("link-port-role", "body", *m.LinkPortRole); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateMappedServiceInterfacePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.MappedServiceInterfacePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.MappedServiceInterfacePoint); i++ {
		if swag.IsZero(m.MappedServiceInterfacePoint[i]) { // not required
			continue
		}

		if m.MappedServiceInterfacePoint[i] != nil {
			if err := m.MappedServiceInterfacePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mapped-service-interface-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeOperationalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DISABLED","ENABLED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeOperationalStatePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeOperationalStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0OperationalStateDISABLED captures enum value "DISABLED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0OperationalStateDISABLED string = "DISABLED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0OperationalStateENABLED captures enum value "ENABLED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0OperationalStateENABLED string = "ENABLED"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateOperationalStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeOperationalStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateOperationalState(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationalStateEnum("operational-state", "body", *m.OperationalState); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeTerminationDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BIDIRECTIONAL","SINK","SOURCE","UNDEFINED_OR_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeTerminationDirectionPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeTerminationDirectionPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationDirectionBIDIRECTIONAL captures enum value "BIDIRECTIONAL"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationDirectionBIDIRECTIONAL string = "BIDIRECTIONAL"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationDirectionSINK captures enum value "SINK"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationDirectionSINK string = "SINK"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationDirectionSOURCE captures enum value "SOURCE"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationDirectionSOURCE string = "SOURCE"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationDirectionUNDEFINEDORUNKNOWN captures enum value "UNDEFINED_OR_UNKNOWN"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationDirectionUNDEFINEDORUNKNOWN string = "UNDEFINED_OR_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateTerminationDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeTerminationDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateTerminationDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.TerminationDirection) { // not required
		return nil
	}

	// value enum
	if err := m.validateTerminationDirectionEnum("termination-direction", "body", *m.TerminationDirection); err != nil {
		return err
	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeTerminationStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["LP_CAN_NEVER_TERMINATE","LT_NOT_TERMINATED","TERMINATED_SERVER_TO_CLIENT_FLOW","TERMINATED_CLIENT_TO_SERVER_FLOW","TERMINATED_BIDIRECTIONAL","LT_PERMENANTLY_TERMINATED","TERMINATION_STATE_UNKNOWN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeTerminationStatePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeTerminationStatePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateLPCANNEVERTERMINATE captures enum value "LP_CAN_NEVER_TERMINATE"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateLPCANNEVERTERMINATE string = "LP_CAN_NEVER_TERMINATE"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateLTNOTTERMINATED captures enum value "LT_NOT_TERMINATED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateLTNOTTERMINATED string = "LT_NOT_TERMINATED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateTERMINATEDSERVERTOCLIENTFLOW captures enum value "TERMINATED_SERVER_TO_CLIENT_FLOW"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateTERMINATEDSERVERTOCLIENTFLOW string = "TERMINATED_SERVER_TO_CLIENT_FLOW"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateTERMINATEDCLIENTTOSERVERFLOW captures enum value "TERMINATED_CLIENT_TO_SERVER_FLOW"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateTERMINATEDCLIENTTOSERVERFLOW string = "TERMINATED_CLIENT_TO_SERVER_FLOW"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateTERMINATEDBIDIRECTIONAL captures enum value "TERMINATED_BIDIRECTIONAL"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateTERMINATEDBIDIRECTIONAL string = "TERMINATED_BIDIRECTIONAL"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateLTPERMENANTLYTERMINATED captures enum value "LT_PERMENANTLY_TERMINATED"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateLTPERMENANTLYTERMINATED string = "LT_PERMENANTLY_TERMINATED"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateTERMINATIONSTATEUNKNOWN captures enum value "TERMINATION_STATE_UNKNOWN"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TerminationStateTERMINATIONSTATEUNKNOWN string = "TERMINATION_STATE_UNKNOWN"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateTerminationStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TypeTerminationStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateTerminationState(formats strfmt.Registry) error {

	if swag.IsZero(m.TerminationState) { // not required
		return nil
	}

	// value enum
	if err := m.validateTerminationStateEnum("termination-state", "body", *m.TerminationState); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0 data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 aggregated node edge point items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 aggregated node edge point items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AggregatedNodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacity
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 available capacity
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSize
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 available capacity total size
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0 data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 available cep layer protocol items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0 struct {

	// none (leaf)
	LayerProtocolQualifier string `json:"layer-protocol-qualifier,omitempty"`

	// none (leaf)
	NumberOfCepInstances uint64 `json:"number-of-cep-instances,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 available cep layer protocol items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0AvailableCepLayerProtocolItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0 data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 mapped service interface point items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0 struct {

	// none (leaf)
	ServiceInterfacePointUUID string `json:"service-interface-point-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 mapped service interface point items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0MappedServiceInterfacePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0NameItems0 data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 name items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0NameItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 name items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacity
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 total potential capacity
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node edge point items0 total potential capacity total size
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeEdgePointItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0 struct {

	// available capacity
	AvailableCapacity *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// none (list)
	ComposedRuleGroup []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0 `json:"composed-rule-group"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0CostCharacteristicItems0 `json:"cost-characteristic"`

	// none (list)
	InterRuleGroup []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0 `json:"inter-rule-group"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0 `json:"latency-characteristic"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NameItems0 `json:"name"`

	// none (list)
	NodeEdgePoint []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NodeEdgePointItems0 `json:"node-edge-point"`

	// A list of risk characteristics for consideration in an analysis of shared risk. Each element of the list represents a specific risk consideration. (list)
	RiskCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RiskCharacteristicItems0 `json:"risk-characteristic"`

	// none (list)
	Rule []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0 `json:"rule"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateComposedRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeEdgePoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRiskCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) validateComposedRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.ComposedRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.ComposedRuleGroup); i++ {
		if swag.IsZero(m.ComposedRuleGroup[i]) { // not required
			continue
		}

		if m.ComposedRuleGroup[i] != nil {
			if err := m.ComposedRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("composed-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) validateInterRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.InterRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.InterRuleGroup); i++ {
		if swag.IsZero(m.InterRuleGroup[i]) { // not required
			continue
		}

		if m.InterRuleGroup[i] != nil {
			if err := m.InterRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inter-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) validateNodeEdgePoint(formats strfmt.Registry) error {

	if swag.IsZero(m.NodeEdgePoint) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeEdgePoint); i++ {
		if swag.IsZero(m.NodeEdgePoint[i]) { // not required
			continue
		}

		if m.NodeEdgePoint[i] != nil {
			if err := m.NodeEdgePoint[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("node-edge-point" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) validateRiskCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.RiskCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.RiskCharacteristic); i++ {
		if swag.IsZero(m.RiskCharacteristic[i]) { // not required
			continue
		}

		if m.RiskCharacteristic[i] != nil {
			if err := m.RiskCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("risk-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) validateRule(formats strfmt.Registry) error {

	if swag.IsZero(m.Rule) { // not required
		return nil
	}

	for i := 0; i < len(m.Rule); i++ {
		if swag.IsZero(m.Rule[i]) { // not required
			continue
		}

		if m.Rule[i] != nil {
			if err := m.Rule[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rule" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacity
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 available capacity
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 available capacity total size
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 composed rule group items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0 struct {

	// none (leaf)
	NodeRuleGroupUUID string `json:"node-rule-group-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 composed rule group items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0ComposedRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0CostCharacteristicItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 cost characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0CostCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0CostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 cost characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0CostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0CostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0CostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0CostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0 struct {

	// none (list)
	AssociatedNodeRuleGroup []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0 `json:"associated-node-rule-group"`

	// available capacity
	AvailableCapacity *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity `json:"available-capacity,omitempty"`

	// The list of costs where each cost relates to some aspect of the TopologicalEntity. (list)
	CostCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0 `json:"cost-characteristic"`

	// The effect on the latency of a queuing process. This only has significant effect for packet based systems and has a complex characteristic. (list)
	LatencyCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0 `json:"latency-characteristic"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0 `json:"name"`

	// A list of risk characteristics for consideration in an analysis of shared risk. Each element of the list represents a specific risk consideration. (list)
	RiskCharacteristic []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0 `json:"risk-characteristic"`

	// none (list)
	Rule []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0 `json:"rule"`

	// total potential capacity
	TotalPotentialCapacity *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity `json:"total-potential-capacity,omitempty"`

	// UUID: An identifier that is universally unique within an identifier space, where the identifier space is itself globally unique, and immutable. An UUID carries no semantics with respect to the purpose or state of the entity.
	// UUID here uses string representation as defined in RFC 4122.  The canonical representation uses lowercase characters.
	// Pattern: [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-' + '[0-9a-fA-F]{4}-[0-9a-fA-F]{12}
	// Example of a UUID in string representation: f81d4fae-7dec-11d0-a765-00a0c91e6bf6 (leaf)
	UUID string `json:"uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssociatedNodeRuleGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCostCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatencyCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRiskCharacteristic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPotentialCapacity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateAssociatedNodeRuleGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.AssociatedNodeRuleGroup) { // not required
		return nil
	}

	for i := 0; i < len(m.AssociatedNodeRuleGroup); i++ {
		if swag.IsZero(m.AssociatedNodeRuleGroup[i]) { // not required
			continue
		}

		if m.AssociatedNodeRuleGroup[i] != nil {
			if err := m.AssociatedNodeRuleGroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("associated-node-rule-group" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateAvailableCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.AvailableCapacity) { // not required
		return nil
	}

	if m.AvailableCapacity != nil {
		if err := m.AvailableCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity")
			}
			return err
		}
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateCostCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.CostCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.CostCharacteristic); i++ {
		if swag.IsZero(m.CostCharacteristic[i]) { // not required
			continue
		}

		if m.CostCharacteristic[i] != nil {
			if err := m.CostCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cost-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateLatencyCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.LatencyCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.LatencyCharacteristic); i++ {
		if swag.IsZero(m.LatencyCharacteristic[i]) { // not required
			continue
		}

		if m.LatencyCharacteristic[i] != nil {
			if err := m.LatencyCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latency-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateRiskCharacteristic(formats strfmt.Registry) error {

	if swag.IsZero(m.RiskCharacteristic) { // not required
		return nil
	}

	for i := 0; i < len(m.RiskCharacteristic); i++ {
		if swag.IsZero(m.RiskCharacteristic[i]) { // not required
			continue
		}

		if m.RiskCharacteristic[i] != nil {
			if err := m.RiskCharacteristic[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("risk-characteristic" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateRule(formats strfmt.Registry) error {

	if swag.IsZero(m.Rule) { // not required
		return nil
	}

	for i := 0; i < len(m.Rule); i++ {
		if swag.IsZero(m.Rule[i]) { // not required
			continue
		}

		if m.Rule[i] != nil {
			if err := m.Rule[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rule" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) validateTotalPotentialCapacity(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalPotentialCapacity) { // not required
		return nil
	}

	if m.TotalPotentialCapacity != nil {
		if err := m.TotalPotentialCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 associated node rule group items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0 struct {

	// none (leaf)
	NodeRuleGroupUUID string `json:"node-rule-group-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 associated node rule group items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AssociatedNodeRuleGroupItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity Capacity available to be assigned. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 available capacity
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("available-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 available capacity total size
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("available-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0AvailableCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 cost characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0 struct {

	// The cost may vary based upon some properties of the TopologicalEntity. The rules for the variation are conveyed by the costAlgorithm. (leaf)
	CostAlgorithm string `json:"cost-algorithm,omitempty"`

	// The cost characteristic will related to some aspect of the TopologicalEntity (e.g. $ cost, routing weight). This aspect will be conveyed by the costName. (leaf)
	CostName string `json:"cost-name,omitempty"`

	// The specific cost. (leaf)
	CostValue string `json:"cost-value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 cost characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0CostCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 latency characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 latency characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0LatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 name items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 name items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 risk characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0 struct {

	// The name of the risk characteristic. The characteristic may be related to a specific degree of closeness.
	// For example a particular characteristic may apply to failures that are localized (e.g. to one side of a road) where as another characteristic may relate to failures that have a broader impact (e.g. both sides of a road that crosses a bridge).
	// Depending upon the importance of the traffic being routed different risk characteristics will be evaluated. (leaf)
	RiskCharacteristicName string `json:"risk-characteristic-name,omitempty"`

	// risk identifier list
	RiskIdentifierList []string `json:"risk-identifier-list"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 risk characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RiskCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 rule items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0 struct {

	// none (leaf)
	// Enum: [MAY_FORWARD_ACROSS_GROUP MUST_FORWARD_ACROSS_GROUP CANNOT_FORWARD_ACROSS_GROUP NO_STATEMENT_ON_FORWARDING]
	ForwardingRule *string `json:"forwarding-rule,omitempty"`

	// none (leaf)
	LocalID string `json:"local-id,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0 `json:"name"`

	// none (leaf)
	OverridePriority uint64 `json:"override-priority,omitempty"`

	// none (leaf)
	// Enum: [FORWARDING CAPACITY COST TIMING RISK GROUPING]
	RuleType *string `json:"rule-type,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 rule items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateForwardingRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRuleType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MAY_FORWARD_ACROSS_GROUP","MUST_FORWARD_ACROSS_GROUP","CANNOT_FORWARD_ACROSS_GROUP","NO_STATEMENT_ON_FORWARDING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP captures enum value "MAY_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP string = "MAY_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP captures enum value "MUST_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP string = "MUST_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP captures enum value "CANNOT_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP string = "CANNOT_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING captures enum value "NO_STATEMENT_ON_FORWARDING"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING string = "NO_STATEMENT_ON_FORWARDING"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateForwardingRuleEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeForwardingRulePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateForwardingRule(formats strfmt.Registry) error {

	if swag.IsZero(m.ForwardingRule) { // not required
		return nil
	}

	// value enum
	if err := m.validateForwardingRuleEnum("forwarding-rule", "body", *m.ForwardingRule); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FORWARDING","CAPACITY","COST","TIMING","RISK","GROUPING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeFORWARDING captures enum value "FORWARDING"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeFORWARDING string = "FORWARDING"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCAPACITY captures enum value "CAPACITY"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCAPACITY string = "CAPACITY"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCOST captures enum value "COST"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeCOST string = "COST"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeTIMING captures enum value "TIMING"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeTIMING string = "TIMING"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeRISK captures enum value "RISK"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeRISK string = "RISK"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeGROUPING captures enum value "GROUPING"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0RuleTypeGROUPING string = "GROUPING"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateRuleTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0TypeRuleTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) validateRuleType(formats strfmt.Registry) error {

	if swag.IsZero(m.RuleType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRuleTypeEnum("rule-type", "body", *m.RuleType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 rule items0 name items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 rule items0 name items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0RuleItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 total potential capacity
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 inter rule group items0 total potential capacity total size
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0InterRuleGroupItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 latency characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0 struct {

	// A TopologicalEntity suffers delay caused by the realization of the servers (e.g. distance related; FEC encoding etc.) along with some client specific processing. This is the total average latency effect of the TopologicalEntity (leaf)
	FixedLatencyCharacteristic string `json:"fixed-latency-characteristic,omitempty"`

	// High frequency deviation from true periodicity of a signal and therefore a small high rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	JitterCharacteristic string `json:"jitter-characteristic,omitempty"`

	// The specific queuing latency for the traffic property. (leaf)
	QueingLatencyCharacteristic string `json:"queing-latency-characteristic,omitempty"`

	// The identifier of the specific traffic property to which the queuing latency applies. (leaf)
	TrafficPropertyName string `json:"traffic-property-name,omitempty"`

	// Low frequency deviation from true periodicity of a signal and therefore a small low rate of change of transfer latency.
	// Applies to TDM systems (and not packet). (leaf)
	WanderCharacteristic string `json:"wander-characteristic,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 latency characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0LatencyCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NameItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 name items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NameItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 name items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NodeEdgePointItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 node edge point items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NodeEdgePointItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NodeEdgePointItems0 struct {

	// none (leaf)
	NodeEdgePointUUID string `json:"node-edge-point-uuid,omitempty"`

	// none (leaf)
	NodeUUID string `json:"node-uuid,omitempty"`

	// none (leaf)
	TopologyUUID string `json:"topology-uuid,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 node edge point items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NodeEdgePointItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NodeEdgePointItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NodeEdgePointItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0NodeEdgePointItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RiskCharacteristicItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 risk characteristic items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RiskCharacteristicItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RiskCharacteristicItems0 struct {

	// The name of the risk characteristic. The characteristic may be related to a specific degree of closeness.
	// For example a particular characteristic may apply to failures that are localized (e.g. to one side of a road) where as another characteristic may relate to failures that have a broader impact (e.g. both sides of a road that crosses a bridge).
	// Depending upon the importance of the traffic being routed different risk characteristics will be evaluated. (leaf)
	RiskCharacteristicName string `json:"risk-characteristic-name,omitempty"`

	// risk identifier list
	RiskIdentifierList []string `json:"risk-identifier-list"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 risk characteristic items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RiskCharacteristicItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RiskCharacteristicItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RiskCharacteristicItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RiskCharacteristicItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 rule items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0 struct {

	// none (leaf)
	// Enum: [MAY_FORWARD_ACROSS_GROUP MUST_FORWARD_ACROSS_GROUP CANNOT_FORWARD_ACROSS_GROUP NO_STATEMENT_ON_FORWARDING]
	ForwardingRule *string `json:"forwarding-rule,omitempty"`

	// none (leaf)
	LocalID string `json:"local-id,omitempty"`

	// List of names. A property of an entity with a value that is unique in some namespace but may change during the life of the entity. A name carries no semantics with respect to the purpose of the entity. (list)
	Name []*DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0NameItems0 `json:"name"`

	// none (leaf)
	OverridePriority uint64 `json:"override-priority,omitempty"`

	// none (leaf)
	// Enum: [FORWARDING CAPACITY COST TIMING RISK GROUPING]
	RuleType *string `json:"rule-type,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 rule items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateForwardingRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRuleType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MAY_FORWARD_ACROSS_GROUP","MUST_FORWARD_ACROSS_GROUP","CANNOT_FORWARD_ACROSS_GROUP","NO_STATEMENT_ON_FORWARDING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP captures enum value "MAY_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleMAYFORWARDACROSSGROUP string = "MAY_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP captures enum value "MUST_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleMUSTFORWARDACROSSGROUP string = "MUST_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP captures enum value "CANNOT_FORWARD_ACROSS_GROUP"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleCANNOTFORWARDACROSSGROUP string = "CANNOT_FORWARD_ACROSS_GROUP"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING captures enum value "NO_STATEMENT_ON_FORWARDING"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0ForwardingRuleNOSTATEMENTONFORWARDING string = "NO_STATEMENT_ON_FORWARDING"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0) validateForwardingRuleEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0TypeForwardingRulePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0) validateForwardingRule(formats strfmt.Registry) error {

	if swag.IsZero(m.ForwardingRule) { // not required
		return nil
	}

	// value enum
	if err := m.validateForwardingRuleEnum("forwarding-rule", "body", *m.ForwardingRule); err != nil {
		return err
	}

	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	for i := 0; i < len(m.Name); i++ {
		if swag.IsZero(m.Name[i]) { // not required
			continue
		}

		if m.Name[i] != nil {
			if err := m.Name[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("name" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FORWARDING","CAPACITY","COST","TIMING","RISK","GROUPING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeFORWARDING captures enum value "FORWARDING"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeFORWARDING string = "FORWARDING"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeCAPACITY captures enum value "CAPACITY"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeCAPACITY string = "CAPACITY"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeCOST captures enum value "COST"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeCOST string = "COST"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeTIMING captures enum value "TIMING"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeTIMING string = "TIMING"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeRISK captures enum value "RISK"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeRISK string = "RISK"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeGROUPING captures enum value "GROUPING"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0RuleTypeGROUPING string = "GROUPING"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0) validateRuleTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0TypeRuleTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0) validateRuleType(formats strfmt.Registry) error {

	if swag.IsZero(m.RuleType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRuleTypeEnum("rule-type", "body", *m.RuleType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0NameItems0 data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 rule items0 name items0
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0NameItems0
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0NameItems0 struct {

	// The value (leaf)
	Value string `json:"value,omitempty"`

	// The name of the value. The value need not have a name. (leaf)
	ValueName string `json:"value-name,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 rule items0 name items0
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0NameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0NameItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0NameItems0) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0RuleItems0NameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacity
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 total potential capacity
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 node rule group items0 total potential capacity total size
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0NodeRuleGroupItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacity An optimistic view of the capacity of the TopologicalEntity assuming that any shared capacity is available to be taken. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacity
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacity struct {

	// total size
	TotalSize *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSize `json:"total-size,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 total potential capacity
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTotalSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacity) validateTotalSize(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalSize) { // not required
		return nil
	}

	if m.TotalSize != nil {
		if err := m.TotalSize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("total-potential-capacity" + "." + "total-size")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacity) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSize Total capacity of the TopologicalEntity in MB/s. In case of bandwidthProfile, this is expected to same as the committedInformationRate. (non-presence)
// swagger:model DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSize
type DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSize struct {

	// none (leaf)
	// Enum: [TB TBPS GB GBPS MB MBPS KB KBPS GHz MHz]
	Unit *string `json:"unit,omitempty"`

	// none (leaf)
	Value uint64 `json:"value,omitempty"`
}

// Validate validates this data tapi topology get topology details post output tapi topology topology node items0 total potential capacity total size
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSize) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TB","TBPS","GB","GBPS","MB","MBPS","KB","KBPS","GHz","MHz"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum = append(dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum, v)
	}
}

const (

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitTB captures enum value "TB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitTB string = "TB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitTBPS captures enum value "TBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitTBPS string = "TBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitGB captures enum value "GB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitGB string = "GB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitGBPS captures enum value "GBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitGBPS string = "GBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitMB captures enum value "MB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitMB string = "MB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitMBPS captures enum value "MBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitMBPS string = "MBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitKB captures enum value "KB"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitKB string = "KB"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitKBPS captures enum value "KBPS"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitKBPS string = "KBPS"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitGHz captures enum value "GHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitGHz string = "GHz"

	// DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitMHz captures enum value "MHz"
	DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeUnitMHz string = "MHz"
)

// prop value enum
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSize) validateUnitEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSizeTypeUnitPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSize) validateUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.Unit) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnitEnum("total-potential-capacity"+"."+"total-size"+"."+"unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSize) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSize) UnmarshalBinary(b []byte) error {
	var res DataTapiTopologyGetTopologyDetailsPostOutputTapiTopologyTopologyNodeItems0TotalPotentialCapacityTotalSize
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
